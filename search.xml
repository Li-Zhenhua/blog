<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>函数调用栈分析</title>
      <link href="/blog-article/2022/10/30/han-shu-diao-yong-zhan-fen-xi/"/>
      <url>/blog-article/2022/10/30/han-shu-diao-yong-zhan-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="函数基本结构"><a href="#函数基本结构" class="headerlink" title="函数基本结构"></a>函数基本结构</h2><p>G语言中函数的声明的基本形式如下：</p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">func name(parameter-list) (result-list) &#123;    body&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中<strong>函数的类型被称为函数的签名</strong>。如果两个函数<strong>形式参数列表</strong>和<strong>返回值列表</strong>中的<strong>变量类型</strong>一一对应，那么这两个函数被认为有相同的类型或签名。</p><p>形参和返回值的<strong>变量名</strong>不影响函数签名，也不影响它们是否可以以省略参数类型的形式表示。</p><p>Go语言的实参通过<strong>值的方式传递</strong>，因此函数的形参是实参的拷贝，只有传递指针、slice(切片)、map、function、channel等类型才可能导致实参的修改。</p><h2 id="函数栈帧布局"><a href="#函数栈帧布局" class="headerlink" title="函数栈帧布局"></a>函数栈帧布局</h2><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7.png" alt="函数栈帧"></p><p>我们用Go语言写的函数，会被编译器编译为一堆机器指令，写入可执行文件，程序执行时，可执行文件被加载到内存，这些机器指令对应到虚拟地址空间中，位于代码段</p><p>如果在一个函数中调用另一个函数，编译器就会对应生成一条<code>call</code>指令，程序执行到这条指令时，就会跳转到被调用函数处开始执行，而每个函数的最后都有一条<code>ret</code>指令，负责在函数结束后跳回到调用处，继续执行。</p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A72.png" /><p>由图中可以看出，一个栈帧的从栈底到栈顶的布局是：</p><blockquote><p> <strong>调用者栈基  =&gt; 局部变量 =&gt; 被调用函数返回值 =&gt; 被调用函数参数</strong></p></blockquote><p>而之前说的<code>call</code>指令，就只做两件事：</p><blockquote><ol><li>将下一条指定的地址入栈，这就是<strong>返回地址</strong>，被调用函数执行结束后会跳回到这里。</li><li>跳转到<strong>被调用函数的入口处</strong>开始执行</li></ol></blockquote><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A73.png"></p><p>所有的函数的栈帧布局都遵循统一的约定，故被调用者是通<strong>过栈指针加上相应的偏移</strong>来定位到每个参数和返回值的</p><blockquote><p>注意，返回地址是被CALL指令压栈的，故其<strong>既不属于调用者栈帧，也不属于被调用者栈帧的内容</strong>。</p></blockquote><h2 id="栈帧的内存分配"><a href="#栈帧的内存分配" class="headerlink" title="栈帧的内存分配"></a>栈帧的内存分配</h2><p>Go语言的栈不是逐步扩张的，而是<strong>一次性分配</strong>，也就是在<strong>分配栈帧时，直接将栈指针移动到所需最大栈空间的位置</strong>，然后通过<strong>栈指针+偏移值这种相对寻址方式</strong>使用函数栈帧。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.PNG"></p><p>之所以这样分配，就是为了防止出现上图中所示的访问越界的情况。</p><p>函数栈帧的大小，可以在编译时期确定，对于栈消耗较大的函数，Go语言的编译器会在<strong>函数头部插入检测代码</strong>，如果发现需要进行“栈增长”，就会另外分配一段足够大的栈空间，并把原来栈上的数据拷贝过来，并且将原来这段栈空间释放。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%802.PNG"></p><h2 id="函数跳转与返回的实现"><a href="#函数跳转与返回的实现" class="headerlink" title="函数跳转与返回的实现"></a>函数跳转与返回的实现</h2><p>假设一个函数$A$在$a1$处调用函数$B$，起初栈内存布局以及寄存器情况如下：</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E8%B7%B3%E8%BD%AC%E4%B8%8E%E8%BF%94%E5%9B%9E.PNG"></p><p>代码执行到$a1$，调用<code>call</code>指令，便会执行两步：</p><ol><li><strong>把下一条指令执行地址$a2$入栈保存起来，即保存到$s3$处</strong></li><li><strong>跳转到指令执行地址$b1$处</strong></li></ol><p>接着函数$B$代码开始执行，先把 $sp$ 向下移动24字节（这里是说明性演示，假设分配的栈帧大小即为24字节），为自己分配足够大的栈帧；接着执行$b2$这条指令，把<strong>调用者栈基</strong><code>(caller’s bp -&gt; s1)</code>存到$sp+16$的地方，接下来$b3$指令把$sp+16$的地址存入栈基寄存器$bp$，接下来就可以执行函数$B$剩下的指令了。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E8%B7%B3%E8%BD%AC%E4%B8%8E%E8%BF%94%E5%9B%9E2.PNG"></p><p>执行完$B$剩余的指令后，在<code>ret</code>指令之前，编译器还会插入两条指令：</p><blockquote><ol><li>恢复调用者$A$的栈基地址，它之前被存储在$sp+16$字节这里，这就是为什么栈帧布局第一条就是<code>caller’s bp</code>的原因，</li><li>释放自己的栈帧空间，分配时向下移动多少，释放时就向上移动多少</li></ol></blockquote><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E8%B7%B3%E8%BD%AC%E4%B8%8E%E8%BF%94%E5%9B%9E3.PNG"></p><p>接着就是<code>ret</code>指令了，其首先是弹出<code>call</code>指令压栈的<strong>返回地址</strong>，这里即为$sp$指向的$a2$；第二，指令指针寄存器跳转到这个返回地址，然后代码就可以重新从$a2$执行了</p><blockquote><p>总的来说，函数通过<code>call</code>指令实现跳转，而每个函数开始时会分配栈帧，结束前又会释放自己的栈帧，<code>ret</code>指令又会把<code>call</code>恢复到<code>call</code>之前的样子，通过这些指令的配合能够实现函数的层层嵌套。</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li>幼麟实验室的Golang合辑</li><li>《Go语言圣经》</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层分析 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数调用栈的传参与返回值</title>
      <link href="/blog-article/2022/01/06/han-shu-diao-yong-zhan-de-chuan-can-yu-fan-hui-zhi/"/>
      <url>/blog-article/2022/01/06/han-shu-diao-yong-zhan-de-chuan-can-yu-fan-hui-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>我们知道，由于Go语言是值传递，如果在被调用函数内部交换两个数的值，调用者内部对应的实参是不会发生变化的，就如下所示：</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/swap%E5%87%BD%E6%95%B0.PNG"></p><p>但这个现象的原因从函数调用栈来说具体的机理是什么呢？我们通过函数调用栈看看问题到底出在哪</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/swap%E6%A0%88%E5%B8%A7.PNG"></p><p>由于函数调用没有返回值，所以局部变量后面就是给被调用函数传入的参数$args$，注意调用函数的<strong>参数入栈顺序由右到左，返回值也是一样</strong>（原因是这样被调用函数通过**$sp$+偏移寻址**就比较方便了）</p><p>可以看出，当<code>swap</code>函数交换两数时，交换的是<code>args</code>内的$a、b$，而不是<code>main</code>函数中的局部变量，所以<code>main</code>函数中的$a、b$交换失败。</p><h2 id="传指针的例子"><a href="#传指针的例子" class="headerlink" title="传指针的例子"></a>传指针的例子</h2><p>同理与上面的例子，我们便可以很容易理解传指针时为什么可以成功交换$a、b$的值</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/swap%E5%87%BD%E6%95%B02.PNG"></p><p>此时的栈帧空间分布如下：</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/swap%E6%A0%88%E5%B8%A72.PNG"></p><p><code>swap</code>执行到<code>*a,*b=*b,*a</code>时，交换的是这两个指针指向的数据，也就是这两个地址的数据，所以这一次能交换成功</p><h2 id="匿名函数返回值"><a href="#匿名函数返回值" class="headerlink" title="匿名函数返回值"></a>匿名函数返回值</h2><p>Go语言支持多返回值，所以在<strong>栈上分配返回值空间</strong>更合适</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%8C%BF%E5%90%8D%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0.PNG"></p><p>首先，栈帧上所有的$a、b$初始均等于0，执行到①处时，被调用函数的参数<code>args</code>上的$a$自增为1，接着执行到②，<code>incr</code>函数栈帧的$b$被赋值等于1。</p><blockquote><p>注：<strong>defer与return时机</strong></p><p>return赋值和返回是两个步骤，不是原子操作，如果有defer会插在两个步骤中:</p><ol><li>返回值赋值(return value)</li><li>defer语句 </li><li>返回值真正返回，调用函数结束</li></ol></blockquote><p>所以<code>return</code>函数先将<code>incr</code>函数栈帧的$b$赋值给返回值，也就是此时的栈空间是这样的</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%8C%BF%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7.PNG"></p><p>接着执行<code>defer</code>函数，<code>args</code>上的$a$再自增1，<code>incr</code>函数局部变量$b$也自增1，然后<code>incr</code>结束。此时返回值为1，所以<code>main</code>函数中的$b$最终被赋值为1，而<code>main</code>函数中的$a$并不会收到<code>incr</code>函数的影响，值仍然为0。最终的栈内布局是这样的：</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%8C%BF%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A72.PNG"></p><p><strong>所以最终输出的是0和1</strong></p><h2 id="具名返回值函数"><a href="#具名返回值函数" class="headerlink" title="具名返回值函数"></a>具名返回值函数</h2><p>假如我们其他都不变，只把这里的局部变量b，改成命名返回值，看看有什么不同</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/6a677dc56a02460b895f40b4063dcdbe.png"></p><p>当执行到<code>a++</code>时，参数$a$自增1，由于是具名返回值函数，此时返回值$b$被赋予为1</p><p>接着<code>defer</code>函数，参数$a$再自增1，返回值b也自增1，<code>incr</code>结束，所以最终返回值$b$的值为2</p><h2 id="调用多个函数时的小问题"><a href="#调用多个函数时的小问题" class="headerlink" title="调用多个函数时的小问题"></a>调用多个函数时的小问题</h2><p>如果一个函数A调用了两个函数B和C。但是这<strong>两个函数的参数和返回值占用的空间并不相同</strong>，而Go语言的函数栈帧是一次性分配的，所以要以<strong>最大的参数加返回值空间为标准来分配栈帧空间</strong>，才能满足所有被调函数的需求</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0.PNG"></p><p>假设B的参数和返回值占用的空间大，当调用B时，B的参数和返回值可以把分配的参数加返回值空间占满没有问题，但是调用B时，B的参数和返回值<strong>只会占用靠近栈顶的那部分空间</strong>（即上图方框中靠下的部分）</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B02.PNG"></p><blockquote><p>原因是虽然上面空出来一块，但是被调用者<strong>通过栈指针相对寻址</strong>自己的参数和返回值时会比较方便</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>幼麟实验室的Golang合辑</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层分析 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原地哈希</title>
      <link href="/blog-article/2021/12/26/yuan-di-ha-xi/"/>
      <url>/blog-article/2021/12/26/yuan-di-ha-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>假设有一个长度$n$的数组，所有数字都在 $0～ n-1$ 的范围内。数组中某些数字可能是重复的，这时要我们找出数组中其中一个重复的数字，且时间复杂度 $O(n)$，空间复杂度为常数，此时应该怎么实现呢？</p></blockquote><hr><p>一般而言，对于这样的问题，通常想法是<strong>排序</strong>或者用一个<strong>Map</strong>进行存储，但是这样都会违背时间或空间复杂度的要求，所以出现了<strong>”原地哈希“</strong>的思想</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>容易知道，对于长度$n$的数组，所有数字都在 $0～ n-1$ 的范围内时，如果没有重复元素，那么数组的索引和值将会是<strong>一对一</strong>的关系。也就是说，<strong>重复</strong>的元素导致了<strong>一对多</strong>的映射关系。</p><p>因此，可以遍历数组，将索引和值进行尽可能多的一一对应映射，即使得 $nums[i] = i$。这样，相当于在<strong>原数组</strong>上进行了一个Map映射，也就是原地哈希名称的由来。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%8E%9F%E5%9C%B0hash.png"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>由上面的算法思路，我们可以知道，如果数组索引和值的映射关系并非一一对应时，运用上述算法我们便可以推广到找数组中重复或缺失的元素</p><blockquote><p>假设一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p></blockquote><p>上述题目中对于每一个索引 $i$，经过元素换位后，索引$i$对应的正整数值 $i+1$ 若出现在数组中，一定已经换位到索引$i$处，其余的索引值要么为非正数，要么大于数组长度$n$。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C2.png"></p><p>总之，找到第一个 $nums[j]!= j$ 位置处即为所要找的数组中最小的未出现过的正整数对应的索引，对应的数值为$j+1$</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> n <span class="token operator">||</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//此时也就是这n个数正好是1~n，所以最小未出现的正整数即为n+1</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原地hash </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang的slice</title>
      <link href="/blog-article/2021/10/31/golang-de-slice/"/>
      <url>/blog-article/2021/10/31/golang-de-slice/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。其实 slice 也就相当于动态数组，长度并不固定，可以用append追加元素，并且slice会在容量不足时自动扩容。</p><p>在go语言中文文档中，对于slice有这样的描述：</p><blockquote><ol><li>切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。</li><li>切片的长度可以改变，因此，切片是一个可变的数组。</li><li>切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 </li><li>cap可以求出slice最大扩张容量，不能超出数组限制。0 &lt;= len(slice) &lt;= len(array)，其中array是slice引用的数组。</li><li>切片的定义：var 变量名 []类型，比如 <code>var str []string</code>     <code>var arr []int</code>。</li><li>如果 slice == nil，那么 len、cap 结果都等于 0。</li></ol></blockquote><h2 id="slice的数据结构"><a href="#slice的数据结构" class="headerlink" title="slice的数据结构"></a>slice的数据结构</h2><p>根据runtime包下的slice.go源码可以看到，slice的基本结构如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> slice <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>array unsafe<span class="token punctuation">.</span>Pointer<span class="token builtin">len</span>   <span class="token builtin">int</span><span class="token builtin">cap</span>   <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>array</code> 是指向第一个slice元素对应的底层数组元素的地址的指针;</li><li><code>len</code> 是当前切片的长度；</li><li><code>cap</code> 是当前切片的容量，即 <code>array</code> 数组的大小：</li></ul><p>注意这里len范围内的元素是可以安全访问的，超出这个范围的元素访问会<strong>导致panic</strong></p><h2 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h3><p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠，如下图所示：</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/ch4-01.png" alt="img"></p><blockquote><p>如果对共用的底层数组切片进行append添加元素，那么就会开辟新数组，不在共用底层数组，原来的元素拷贝过去，并且在新数组上添加新元素。</p></blockquote><h3 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h3><p>和数组不同的是，slice之间不能比较，因此我们<strong>不能使用==操作符来判断两个slice是否含有全部相等元素</strong>。不过标准库提供了高度优化的<code>bytes.Equal</code>函数来判断两个字节型slice是否相等（限于**[]byte**），但是对于其他类型的slice，我们必须自己展开每个元素进行比较</p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">func equal(x, y []string) bool &#123;    if len(x) !&#x3D; len(y) &#123;        return false    &#125;    for i :&#x3D; range x &#123;        if x[i] !&#x3D; y[i] &#123;            return false        &#125;    &#125;    return true&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果==使用的是<strong>浅度相等</strong>，只要两个slice的指针，长度和容量三个字段相等，那么两个slice就相等。但这样和数组不同的相等测试方法，会让人困惑，如：</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 两个数组相等</span>    a1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    a2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a1 <span class="token operator">==</span> a2<span class="token punctuation">)</span>    <span class="token comment">// true</span>    <span class="token comment">// 如果slice使用的是浅相等</span>    a1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    a2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a1 <span class="token operator">==</span> a2<span class="token punctuation">)</span>   <span class="token comment">// false，和数组的行为不同，造成困惑</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果==使用的是<strong>深度相等</strong>，和数组的行为保持一致，那也会有下面的问题。正常情况下，将一个slice赋值给另一个slice时，我们只是复制slice的结构体，<strong>两个slice的指针都指向同一个底层数组</strong>。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    s1 <span class="token operator">:=</span> s0    s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>   <span class="token comment">// 通过s1修改，会影响到s0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>slice唯一合法的比较操作是和nil比较</strong></p><h2 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h2><p>在slice.go下，有一个扩容growslice函数，当切片的容量不足时，便会调用该函数进行切片扩容，关键源码如下所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> slice <span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token operator">...</span>    newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>    doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap    <span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">></span> doublecap <span class="token punctuation">&#123;</span>       newcap <span class="token operator">=</span> <span class="token builtin">cap</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span> <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">&#123;</span>          newcap <span class="token operator">=</span> doublecap       <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// Check 0 &lt; newcap to detect overflow</span>          <span class="token comment">// and prevent an infinite loop.</span>          <span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">&#123;</span>             newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span>          <span class="token punctuation">&#125;</span>          <span class="token comment">// Set newcap to the requested cap when</span>          <span class="token comment">// the newcap calculation overflowed.</span>          <span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>             newcap <span class="token operator">=</span> <span class="token builtin">cap</span>          <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，扩容的具体规则为：</p><ol><li>如果期望容量<strong>大于当前容量的两倍</strong>就会使用期望容量；</li><li>如果当前切片的长度<strong>小于 1024</strong> 就会将容量<strong>翻倍</strong>；</li><li>如果当前切片的长度<strong>大于 1024</strong> 就会<strong>每次增加 25% 的容量</strong>，直到新容量大于期望容量；</li></ol><p>上述过程仅是进行了新容量的预估，接下来还需要根据切片中的元素大小<strong>对齐内存</strong>。</p><blockquote><p>比如新容量是3，<code>int</code>类型，则它需要申请<code>24B</code>的内存，此时它会向语言自身的<strong>内存管理模块</strong>去申请内存</p><p>而内存管理模块会提前向操作系统申请一批内存，分为常用的规格管理起来，我们申请内存时，它会帮我们<strong>匹配到足够大，且最接近规格的内存</strong>，可能这里内存管理模块分配给你了<code>32B</code>的内存，所以这个时候新容量变成4个了</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/image-20220105003609592.png" alt="image-20220105003609592"></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//runtime下sizeclasses.go文件，基本的内存单元如下</span><span class="token keyword">var</span> class_to_size <span class="token operator">=</span> <span class="token punctuation">[</span>_NumSizeClasses<span class="token punctuation">]</span><span class="token builtin">uint16</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">,</span> <span class="token number">112</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">144</span><span class="token punctuation">,</span> <span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">176</span><span class="token punctuation">,</span> <span class="token number">192</span><span class="token punctuation">,</span> <span class="token number">208</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">240</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">288</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">352</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">416</span><span class="token punctuation">,</span> <span class="token number">448</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">576</span><span class="token punctuation">,</span> <span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">704</span><span class="token punctuation">,</span> <span class="token number">768</span><span class="token punctuation">,</span> <span class="token number">896</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">1152</span><span class="token punctuation">,</span> <span class="token number">1280</span><span class="token punctuation">,</span> <span class="token number">1408</span><span class="token punctuation">,</span> <span class="token number">1536</span><span class="token punctuation">,</span> <span class="token number">1792</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">,</span> <span class="token number">2304</span><span class="token punctuation">,</span> <span class="token number">2688</span><span class="token punctuation">,</span> <span class="token number">3072</span><span class="token punctuation">,</span> <span class="token number">3200</span><span class="token punctuation">,</span> <span class="token number">3456</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">4864</span><span class="token punctuation">,</span> <span class="token number">5376</span><span class="token punctuation">,</span> <span class="token number">6144</span><span class="token punctuation">,</span> <span class="token number">6528</span><span class="token punctuation">,</span> <span class="token number">6784</span><span class="token punctuation">,</span> <span class="token number">6912</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">,</span> <span class="token number">9472</span><span class="token punctuation">,</span> <span class="token number">9728</span><span class="token punctuation">,</span> <span class="token number">10240</span><span class="token punctuation">,</span> <span class="token number">10880</span><span class="token punctuation">,</span> <span class="token number">12288</span><span class="token punctuation">,</span> <span class="token number">13568</span><span class="token punctuation">,</span> <span class="token number">14336</span><span class="token punctuation">,</span> <span class="token number">16384</span><span class="token punctuation">,</span> <span class="token number">18432</span><span class="token punctuation">,</span> <span class="token number">19072</span><span class="token punctuation">,</span> <span class="token number">20480</span><span class="token punctuation">,</span> <span class="token number">21760</span><span class="token punctuation">,</span> <span class="token number">24576</span><span class="token punctuation">,</span> <span class="token number">27264</span><span class="token punctuation">,</span> <span class="token number">28672</span><span class="token punctuation">,</span> <span class="token number">32768</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li>《Go语言设计与实现》</li><li>《Go语言圣经》</li><li> 幼麟实验室的Golang合辑</li><li>Go语言中文文档</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层分析 </tag>
            
            <tag> slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog-article/2021/10/27/hello-world/"/>
      <url>/blog-article/2021/10/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
