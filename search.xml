<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>泛型的多态</title>
      <link href="/2022/07/01/fan-xing-de-duo-tai/"/>
      <url>/2022/07/01/fan-xing-de-duo-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在复习泛型时，看到一个关于泛型的多态的知识点。感觉挺有意思的，在这里记录一下。</p><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>我们都知道，泛型是作用于编译期，是为了在编译期保证类型约束与提供类型安全型的，在编译过程泛型会被擦除，运行期不会得到对应的泛型信息。对于无限制的泛型参数，擦除后会被直接替换成Object；对于有限制的泛型参数，会被替换成<del>上下界</del>上界，比如<code>&lt;T extends Number&gt;</code>和<code>&lt;? extends Number&gt;</code>会被替换成上界Number，<code>&lt;? super Number&gt;</code>会被替换成上界Object。</p><p>问题就从这里来了，泛型擦除会导致多态出现问题。比如有一个这样的父类和其子类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">T</span> <span class="token keyword">var</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">var</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">SmsMessage</span> <span class="token keyword">extends</span> <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> <span class="token keyword">var</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">var</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过泛型擦除之后，按照理论来说将会得到下面这样的结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> <span class="token keyword">var</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">var</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmsMessage</span> <span class="token keyword">extends</span> <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> <span class="token keyword">var</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">var</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，父类和其子类定义的参数和返回值将会不一样，这样两者就不是Override（重写）的关系了，而应该是Overload（重载）关系。</p><p>而多态的定义是：<strong>同一个行为具有多个不同表现形式或形态的能力</strong>，多态有三个的必要条件：</p><blockquote><p>1、要有继承</p><p>2、要有override（重写）</p><p>3、父类引用指向子类对象</p></blockquote><p>可见如果不能实现重写将会导致多态不能实现。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>JVM采用了一个叫做<strong>桥接</strong>的特殊方法解决类型擦除和多态的冲突问题。</p><p>通过javap命令对编译后的SmsMessage.class文件进行反编译，得到下面的反编译后的结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SmsMessage</span> <span class="token keyword">extends</span> <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Integer</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token class-name">SmsMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Integer</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Integer</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，编译后的类中其实存在两个get方法，分别对应于上文所说的父类、子类的get方法，而第二个get方法其实就是所谓的桥接方法。我们进一步用javap -c反编译得到字节码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SmsMessage</span> <span class="token keyword">extends</span> <span class="token class-name">Message</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Integer</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>  <span class="token class-name">SmsMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Code</span><span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aload_0       <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment">// Method Message."&lt;init>":()V</span>       <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>  <span class="token keyword">public</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Integer</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Integer</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Code</span><span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aload_1       <span class="token number">1</span><span class="token operator">:</span> areturn  <span class="token keyword">public</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Object</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Code</span><span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aload_0       <span class="token number">1</span><span class="token operator">:</span> aload_1       <span class="token number">2</span><span class="token operator">:</span> checkcast     #<span class="token number">7</span>                  <span class="token comment">// class java/lang/Integer</span>       <span class="token number">5</span><span class="token operator">:</span> invokevirtual #<span class="token number">9</span>                  <span class="token comment">// Method get:(Ljava/lang/Integer;)Ljava/lang/Integer;</span>       <span class="token number">8</span><span class="token operator">:</span> areturn<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，在第二个get方法的<code>5: invokevirtual #9</code>处，调用了第一个get方法，这个桥接方法就搭建起了父类和子类间的桥梁，使得多态与泛型擦除不会存在冲突问题了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/2022/06/20/git-chang-yong-ming-ling/"/>
      <url>/2022/06/20/git-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近实习的过程中，不时要用到一些Git指令，而这些Git使用的频率相对来说也没有那么高，所以经常用了一次之后过一段时间又忘了，还得继续去问狗哥，所以在这里做一个笔记式的Git备注方便以后查询</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p><strong>git init</strong> 初始化仓库</p><p><strong>git add [filename]</strong> 添加某个文件到暂存区</p><p><strong>git add .</strong> 将所有文件添加到暂存区</p><p><strong>git commit -m [message]</strong> 提交暂存区到本地仓库</p><p><strong>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</strong> 本地仓库上传到远程仓库<br><strong>git push &lt;远程主机名&gt; &lt;分支名&gt;</strong>  本地分支名与远程分支名名称相同时的简写<br><strong>git push</strong>  更简写的方式，将当前所处分支推送到链接的上游分支</p><p><strong>git pull</strong> 拉取远程分支，并与本地分支merge<br><strong>git pull [remote] [branch]</strong> 拉取远程指定分支，并当前本地分支merge</p><h2 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h2><p><strong>git branch</strong> 查看所有本地分支<br><strong>git branch -r</strong> 查看所有远程分支<br><strong>git branch -a</strong>  查看所有本地和远程分支</p><p><strong>git checkout [branch]</strong> 切换分支<br><strong>git checkout -b [branch]</strong> 基于当前分支新建分支并切换到该分支</p><p><del><strong>git branch –set-upstream [branch] [remote-branch]</strong></del><br><strong>git branch –set-upstream-to=origin/[remote-branch]</strong> 建立本地分支与远程分支的追踪关系</p><p><strong>git branch -d [branch]</strong> 删除本地分支<br><strong>git push origin –delete [remote-branch]</strong> 删除远程分支</p><p><strong>git merge [other-branch]</strong> 合并其他分支到当前分支</p><p><strong>git cherry-pick [commit]</strong> 选择一个commit，合并进当前分支</p><h2 id="撤销命令"><a href="#撤销命令" class="headerlink" title="撤销命令"></a>撤销命令</h2><p><strong>git checkout [fileName]</strong> 恢复暂存区文件到工作区<br><strong>git checkout .</strong> 恢复暂存区的所有文件到工作区</p><p><strong>git reset –hard HEAD^/[commitId]</strong> 重置到上一次commit/指定的commit，并将暂存区和工作区都清空，也就是说，最后一次的commit被完全清空<br><strong>git reset –mixed HEAD^/[commitId]</strong> 重置到上一次commit/指定的commit，并将暂存区清空，工作区还有最后一次commit修改的内容，也就是返回到git add之前的状态<br><strong>git reset –soft HEAD^/[commitId]</strong> 重置到上一次commit/指定的commit，暂存区和工作区还有最后一次commit修改的内容，也就是返回到git commit之前的状态</p><h2 id="暂存堆栈命令"><a href="#暂存堆栈命令" class="headerlink" title="暂存堆栈命令"></a>暂存堆栈命令</h2><p><strong>git stash</strong> 保存当前工作进度，工作区和暂存区都会保存起来<br><strong>git stash pop</strong> 恢复最近工作记录到工作区<br><strong>git stash pop –index</strong> 恢复最近工作记录到暂存区和工作区<br>**git stash pop stash@{stashId} **恢复指定工作记录到工作区<br><strong>git stash list</strong> 显示所有保存的stash列表</p><h2 id="查看信息命令"><a href="#查看信息命令" class="headerlink" title="查看信息命令"></a>查看信息命令</h2><p><strong>git log</strong> 显示当前分支的版本历史</p><p><strong>git status</strong> 显示有变更的文件状态，给出一定的操作提示</p><h2 id="补充命令"><a href="#补充命令" class="headerlink" title="补充命令"></a>补充命令</h2><blockquote><p>强制将本地分支与远程分支同步：</p><p>1、git fetch –all<br>2、git reset –hard origin/[远程分支名]</p><p>最后可以用git pull检查一下是否最新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于打印日志的建议</title>
      <link href="/2022/06/06/guan-yu-da-yin-ri-zhi-de-jian-yi/"/>
      <url>/2022/06/06/guan-yu-da-yin-ri-zhi-de-jian-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>平常自己try-catch异常的时候，经常为了方便就写一个e.printStackTrace，如果出现bug，虽然经过一段翻找也能定位到问题产生的位置，但是这其实只是因为自己平常练习的项目就是一个小demo，甚至是玩具级别的东西，直接e.printStackTrace也不会出现什么太大的问题。最近在学log4j2和slf4j的区别时，偶然看到e.printStackTrace是有缺陷的：</p><blockquote><p>1、<strong>占用内存太多，容易造成死锁</strong></p><ul><li>因为e.printStackTrace是直接打印到控制台上，产生的字符串要存放在字符串常量池中，而字符串常量池在JDK1.8之后存放在堆中，此时字符串常量池的大小受限于堆的大小，而如果e.printStackTrace产生的堆栈字符串信息如果太多，会导致内存空间严重不足，后续的请求就会因此被阻塞住了</li></ul><p>2、<strong>日志交错混合，不易读</strong></p><ul><li>e.printStackTrace默认使用了System.err输出流进行输出，与System.out是两个不同的输出流，在打印时自然就形成了交叉。由于输出流是有缓冲区的，交叉的两个流会导致输出随机化</li></ul></blockquote><p>因而打印日志的时候，最好还是使用日志框架slf4j。以下是几个常见的日志打印建议，这里进行一个记录以备后续查找</p><h2 id="日志打印的一些建议"><a href="#日志打印的一些建议" class="headerlink" title="日志打印的一些建议"></a>日志打印的一些建议</h2><h3 id="1、日志打印要打印入参、出参关键信息"><a href="#1、日志打印要打印入参、出参关键信息" class="headerlink" title="1、日志打印要打印入参、出参关键信息"></a>1、日志打印要打印入参、出参关键信息</h3><p>方法进来时，打印关键的入参信息，比如userId等，方法返回的时候，打印出参，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getTestCaseInfo</span><span class="token punctuation">(</span><span class="token class-name">Case</span> <span class="token keyword">case</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Case name:&#123;&#125;"</span><span class="token punctuation">,</span><span class="token keyword">case</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">"2333"</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"return value：&#123;&#125;"</span><span class="token punctuation">,</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> message<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、配置合适的日志格式"><a href="#2、配置合适的日志格式" class="headerlink" title="2、配置合适的日志格式"></a>2、配置合适的日志格式</h3><p>参考的logback配置：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d&#123;HH:mm:ss.SSS&#125; %-5level [%thread][%logger&#123;0&#125;] %m%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>日志应该包含诸如<strong>当前时间、线程名、日志级别</strong>等信息</p><h3 id="3、日志级别较低时，利用开关判断是否打印"><a href="#3、日志级别较低时，利用开关判断是否打印" class="headerlink" title="3、日志级别较低时，利用开关判断是否打印"></a>3、日志级别较低时，利用开关判断是否打印</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">666L</span><span class="token punctuation">,</span> <span class="token string">"DestiNation"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>log<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"userName: &#123;&#125;"</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、使用slf4j日志框架API"><a href="#4、使用slf4j日志框架API" class="headerlink" title="4、使用slf4j日志框架API"></a>4、使用slf4j日志框架API</h3><p>slf4j是一个统一的门面式的日志框架，底层日志系统（log4j、log4j2、logback等）可以更换，一般而言，日志系统的接口都是有一定差别的，而使用slf4j可以在不更改代码的情况下，统一对外的调用接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//方法一，注解</span><span class="token annotation punctuation">@slf4j</span><span class="token comment">//方法二</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">Use</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、使用占位符"><a href="#5、使用占位符" class="headerlink" title="5、使用占位符"></a>5、使用占位符</h3><p>这个不用多说，如果直接使用+号进行字符串拼接会造成性能损失（拼接字符串一般也是用StringBuffer或者StringBuilder），而使用占位符{}仅是替换操作，有效提升性能</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"User id: &#123;&#125;, name : &#123;&#125; "</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6、要输出全部的错误信息"><a href="#6、要输出全部的错误信息" class="headerlink" title="6、要输出全部的错误信息"></a>6、要输出全部的错误信息</h3><p>不要用e.getMessage(),这个方法只会记录基本的错误描述，没有具体的堆栈信息，有可能不利于问题的排查，正确做法是直接输出e</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//执行的业务代码</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"catch exception: "</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7、日志文件分离"><a href="#7、日志文件分离" class="headerlink" title="7、日志文件分离"></a>7、日志文件分离</h3><ul><li>根据不同的类型分离，如error、warn不同等级</li><li>根据不同的业务分离</li></ul><h3 id="8、可以使用异步方式输出日志"><a href="#8、可以使用异步方式输出日志" class="headerlink" title="8、可以使用异步方式输出日志"></a>8、可以使用异步方式输出日志</h3><p>日志输出要用到输出流，异步可以提升IO性能</p><p>logback参考配置：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>FILE_ASYNC<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.AsyncAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ASYNC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 工程应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组和线段树</title>
      <link href="/2022/06/06/shu-zhuang-shu-zu-he-xian-duan-shu/"/>
      <url>/2022/06/06/shu-zhuang-shu-zu-he-xian-duan-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天做每日一题的时候，看到是一道关于区间的困难题，想了一阵感觉有点像需要所谓的线段树来解，之前感觉线段树老麻烦了一直没有学明白，今天就尽可能整理清楚，看看大佬们的题解试着消化理解一下</p><blockquote><p>首先针对区间的一系列问题，可以依据实际情况区分为以下几种：</p><p>1、数组不变，求区间和：「前缀和」、「树状数组」、「线段树」</p><p>2、多次修改某个区间，输出最终结果：「差分」</p><p>3、多次修改某个数，求区间和：「树状数组」、「线段树」</p><p>4、多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小）</p><p>5、多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间范围大小）</p></blockquote><p>因为线段树的代码一般会比较繁琐，所以除了第4、5种问题不得不用线段树时，才考虑线段树。根据上面总结的情况，对于区间和的问题，可以按照这样的顺序选择解法：</p><blockquote><p>1、简单求区间和，用「前缀和」</p><p>2、多次将某个区间变成同一个数，用「线段树」</p><p>3、其他情况，用「树状数组」</p></blockquote><p>前缀和很常见也很容易理解，重点是理解树状数组和线段树，下面先了解了解树状数组</p><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>树状数组和线段树又类似的功能，如果简单地类比描述，可以认为树状数组是线段树的子集，即树状数组有的功能线段树一定有，反之则不一定。</p><p>首先我们假设一个简单的场景需求：要能够方便更新一个数组中某个元素的值并方便快速地返回数组某个区间的和值，这种情况就可以使用树状数组。我们直接给出树状数组的全部代码，先从整体感受一下树状数组的写法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">NumArray</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 累加和</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sums<span class="token punctuation">;</span>        <span class="token comment">// 更新后数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">NumArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// sum从1开始有效, 因为计算lowbit时,如果使用下标0会进入死循环</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>sums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>            <span class="token comment">// 初始化累加和数组</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 下标+1</span>            <span class="token keyword">int</span> indexSum <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>indexSum <span class="token operator">&lt;</span> sums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sums<span class="token punctuation">[</span>indexSum<span class="token punctuation">]</span> <span class="token operator">=</span> sums<span class="token punctuation">[</span>indexSum<span class="token punctuation">]</span> <span class="token operator">+</span> val<span class="token punctuation">;</span>                indexSum <span class="token operator">+=</span> <span class="token function">lowBit</span><span class="token punctuation">(</span>indexSum<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">lowBit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> indexSum <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>indexSum <span class="token operator">&lt;</span> sums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 减去之前nums[index]的值, 加上新的值</span>                sums<span class="token punctuation">[</span>indexSum<span class="token punctuation">]</span> <span class="token operator">=</span> sums<span class="token punctuation">[</span>indexSum<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> val<span class="token punctuation">;</span>                indexSum <span class="token operator">+=</span> <span class="token function">lowBit</span><span class="token punctuation">(</span>indexSum<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>right <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">query</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                ans <span class="token operator">+=</span> sums<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>                x <span class="token operator">-=</span> <span class="token function">lowBit</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> ans<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="累加和数组"><a href="#累加和数组" class="headerlink" title="累加和数组"></a>累加和数组</h3><p>首先看一下累加和sums，图形化理解如下图所示：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E5%9B%BE%E8%A7%A3.png"></p><p>其实从这张图片可以清晰看到，累加和数组就是有种树的性质，然后其实 前缀和也可以很容易从累加和得到，例如：<br>$$<br>prefixSum[6] = sum[4] + sum[6]<br>$$<br>初始化累加和的时候，对应于上图其实是整体流程从下往上的，一次遍历数组nums，判断nums[i]影响了哪些sum，比如，nums[0]影响了sum[1]、sum[2]、sum[4]、sum[8]，而nums[2]影响了sum[3]、sum[4]、sum[8]，代码段：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>indexSum <span class="token operator">&lt;</span> sums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sums<span class="token punctuation">[</span>indexSum<span class="token punctuation">]</span> <span class="token operator">=</span> sums<span class="token punctuation">[</span>indexSum<span class="token punctuation">]</span> <span class="token operator">+</span> val<span class="token punctuation">;</span>    indexSum <span class="token operator">+=</span> <span class="token function">lowBit</span><span class="token punctuation">(</span>indexSum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>就是依次更新当前nums[i]影响的sum[j]的值，这个<code>lowBit()</code>函数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">lowBit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过位运算的方式，找到x的最低位的1并只保留这个1，比如5，二进制101，-5二进制011（忽略符号位），则两者进行&amp;运算之后，结果是001，从而<code>lowBit(5) = 1</code>；再比如，10的二进制1010，-10的二进制0110（忽略符号位），二者取&amp;结果为0010，即<code>lowBit(10) = 4</code>。</p><p>回到上面的代码，通过找到当前<code>indexSum</code>的只保留最低位1的那个数，并与其相加，从而得到**上层中受到nums[i]影响的sum[j]**，图解如下：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E5%9B%BE%E8%A7%A32.png"></p><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p>如果此时我们要更新nums数组中index位置的元素，那么就可以如同上述的流程一样，依次从indexSum = index + 1开始，依次判断nums[index]影响了哪些sum[j]，用<code>lowBit()</code>找到下一个上层sum[j]的位置，这部分代码就很清晰易懂了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> indexSum <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>indexSum <span class="token operator">&lt;</span> sums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 减去之前nums[index]的值, 加上新的值</span>        sums<span class="token punctuation">[</span>indexSum<span class="token punctuation">]</span> <span class="token operator">=</span> sums<span class="token punctuation">[</span>indexSum<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> val<span class="token punctuation">;</span>        indexSum <span class="token operator">+=</span> <span class="token function">lowBit</span><span class="token punctuation">(</span>indexSum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询区间和"><a href="#查询区间和" class="headerlink" title="查询区间和"></a>查询区间和</h3><p>有了上面的基础，其实这部分就更好理解了，平常最常用的区间和是通过前缀和相减获得，这里可以首先将累加和sum转换成前缀和，也就是对应这部分代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ans <span class="token operator">+=</span> sums<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>        x <span class="token operator">-=</span> <span class="token function">lowBit</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与更新操作不同，这部分通过每次减去<code>lowBit(x)</code>得到<strong>前一部分和值</strong>的位置，直到减为零，图解如下：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84_%E5%9B%BE%E8%A7%A33.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实树状数组的关键逻辑非常简单，明白<code>lowBit()</code>函数以及通过相加、相减找下一层的元素的流程，就可以理解整体的功能实现了！</p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>写了半天，总算是到这个折磨了我很久的线段树了。前面已经介绍过，线段树满足的需求除了求区间和，还可满足修改某一个区间的值，时间复杂度都是O(logn)，线段树的基本结构如下：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E7%BA%BF%E6%AE%B5%E6%A0%91_%E7%BB%93%E6%9E%84.png"></p><p>这里对应的nums数组为<code>[1, 2, 3, 4, 5]</code>，线段树的叶子节点就对应于nums数组的每一个元素，父节点表示其两边子节点的的元素值之和，因此每一个节点的值就对应底下的区间的和值</p><p>对于线段树的每一个节点，我们可以用一个Node类表示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span> left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>线段树中查找某一个区间的，就是在线段树中从根节点向树的两边递归找到包含于查询区间的小区间，比如上图的线段树中查找[2,4]范围的区间和，那整个过程会如下图所示</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E7%BA%BF%E6%AE%B5%E6%A0%91_%E6%9F%A5%E8%AF%A2png.png"></p><p>沿着上述的路径，找到两个黄色的节点，此时两个黄色节点的区间范围之和正好等于要查询的区间范围，因此此时查询的结果为<code>3 + 9 = 12</code>。</p><p>代码模板:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// [start, end]为当前查找到的节点的区间范围，[l,r]为需要查询的区间范围,[l,r]保持不变</span>    <span class="token comment">//此时当前找到的节点区间不包含在要查询找的区间之中</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">></span> end <span class="token operator">||</span> r <span class="token operator">&lt;</span> start<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 当[l,r]包含[start, end]时，直接返回当前节点的值</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token comment">// 把当前区间 [start, end] 均分得到左右孩子的区间范围</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// [start, mid] 和 [l, r] 可能有交集，遍历左孩子区间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// [mid + 1, end] 和 [l, r] 可能有交集，遍历右孩子区间</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">></span> mid<span class="token punctuation">)</span> ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ans 把左右子树的结果都累加起来了，与树的后续遍历同理</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更新操作-1"><a href="#更新操作-1" class="headerlink" title="更新操作"></a>更新操作</h3><p>更新操作和查询操作其实与查询是非常类似的，毕竟要更新元素的值首先肯定得先查找到对应得位置，但是，这里有个小优化：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E7%BA%BF%E6%AE%B5%E6%A0%91_%E6%9B%B4%E6%96%B0.png"></p><p>如上图，朴素得想法是，我们每次更新都要更新到叶子节点，比如更新[2,4]区间，那一般肯定是索引为2、3、4得这三个节点都要更新，但是，查询的时候我们查到黄色的节点就可以了，更新了[3,4]区间那么理论上[3,3]、[4,4]区间都会更新，因此没必要查找到诸如红色的叶子节点，因此，这样的线段树可以使用一个懒标记标明该节点的所有子节点都应该有更新，懒标记的值就是每个叶子节点需要更新的值。</p><p>改进后的Node节点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span> left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token comment">// 懒标记</span>    <span class="token keyword">int</span> add<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在需要遍历孩子节点的时候，就将该「懒标记」<strong>下推</strong>给子节点，下推懒标记的的代码模板如下，代码中leftNum表示左子树的节点个数，rightNum表示右子树的节点个数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pushDown</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> leftNum<span class="token punctuation">,</span> <span class="token keyword">int</span> rightNum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//如果节点不存在左右孩子节点，那么我们就创建左右孩子节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果 add 为 0，表示没有标记，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>add <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token comment">// 当前节点的左右子节点加上对应的标记总和值</span>    node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">+=</span> node<span class="token punctuation">.</span>add <span class="token operator">*</span> leftNum<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token operator">+=</span> node<span class="token punctuation">.</span>add <span class="token operator">*</span> rightNum<span class="token punctuation">;</span>    <span class="token comment">// 把标记下推给孩子节点</span>    node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>add <span class="token operator">=</span> node<span class="token punctuation">.</span>add<span class="token punctuation">;</span>    node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>add <span class="token operator">=</span> node<span class="token punctuation">.</span>add<span class="token punctuation">;</span>    <span class="token comment">// 取消当前节点标记</span>    node<span class="token punctuation">.</span>add <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了以上的基础，那么，更新操作的代码模板如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 区间节点加上更新值</span>        node<span class="token punctuation">.</span>val <span class="token operator">+=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> val<span class="token punctuation">;</span>        <span class="token comment">// 添加懒标记</span>        node<span class="token punctuation">.</span>add <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// 下推标记</span>    <span class="token function">pushDown</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mid <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">></span> mid<span class="token punctuation">)</span> <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 向上更新</span>    <span class="token function">pushUp</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个向上更新pushUp函数，这个函数里面并不是固定的，而是根据实际问题的具体需求而定，常见的有：</p><ul><li>数字之和</li><li>最大值</li><li>最大公因数 等</li></ul><p>例如数字之和，则对应的代码为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pushUp</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    node<span class="token punctuation">.</span>val <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其实这个就相当于在当前节点的递归的最后一步：更新完子节点后回到当前节点，更新当前节点的值</p><h3 id="总体代码"><a href="#总体代码" class="headerlink" title="总体代码"></a>总体代码</h3><p>根据上述的阐释，线段树的一种完整的模板代码如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SegmentTreeDynamic</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> left<span class="token punctuation">,</span> right<span class="token punctuation">;</span>        <span class="token keyword">int</span> val<span class="token punctuation">,</span> add<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">private</span> <span class="token class-name">Node</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            node<span class="token punctuation">.</span>val <span class="token operator">+=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> val<span class="token punctuation">;</span>            node<span class="token punctuation">.</span>add <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">pushDown</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mid <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">></span> mid<span class="token punctuation">)</span> <span class="token function">update</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pushUp</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">></span> end <span class="token operator">||</span> r <span class="token operator">&lt;</span> start<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> start <span class="token operator">&amp;&amp;</span> end <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">pushDown</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mid <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end <span class="token operator">-</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">></span> mid<span class="token punctuation">)</span> ans <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pushUp</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//对应于数值之和的实际问题</span>        node<span class="token punctuation">.</span>val <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pushDown</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> leftNum<span class="token punctuation">,</span> <span class="token keyword">int</span> rightNum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>add <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>        node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val <span class="token operator">+=</span> node<span class="token punctuation">.</span>add <span class="token operator">*</span> leftNum<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val <span class="token operator">+=</span> node<span class="token punctuation">.</span>add <span class="token operator">*</span> rightNum<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>add <span class="token operator">=</span> node<span class="token punctuation">.</span>add<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>add <span class="token operator">=</span> node<span class="token punctuation">.</span>add<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>add <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>经过一番整理，线段树的结构以及使用变得清晰许多，线段树依赖懒标记实现了更新数据的方便快捷性，由于线段树本身也是一颗实实在在的树，叶子节点对应nums数组的元素，因此，单纯只更新一个节点的值的时候，必须找到叶子节点去，更新这一条路径的所有节点，因此这也就是为什么此时的线段树和树状数组基本是一样的原因了，此时写树状数组当时是代码更简洁一些的</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompletableFuture学习</title>
      <link href="/2022/06/03/completablefuture-xue-xi/"/>
      <url>/2022/06/03/completablefuture-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近实习用TypeScript多了之后，学js/ts异步编程Promise或者async/await，隐约记得当时学习多线程的时候Java也有一个Future类用于异步编程，这次便想着系统地学习整理一下关于Future的用法以及基本原理</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CompletableFuture </tag>
            
            <tag> 异步编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作内存刷新时机</title>
      <link href="/2022/05/26/gong-zuo-nei-cun-shua-xin-shi-ji/"/>
      <url>/2022/05/26/gong-zuo-nei-cun-shua-xin-shi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前一阵子学习多线程时，学到volatile是保证了线程之间的可见性，volatile对应的内存语义为：</p><blockquote><p>1、写一个volatile变量时，将工作内存共享变量刷新到主内存</p><p>2、读一个volatile变量时，将工作内存置为无效，从主内存中读取共享变量</p></blockquote><p>对于非volatile变量，如果没有加锁的操作，就不能保证多线程之间是可见的，但是在练习的时候就碰到了如下的一个例子：</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>话不多说，直接上代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> test <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始值："</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"更改值："</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码首先是设置了一个共享变量flag，默认为true，线程t1在<code>flag=true</code>的时候执行循环，线程t2会的功能是设置flag=false，本意是使得线程t1可以退出循环，而t2执行的时候sleep一段时间也是保证t1先行与t2运行。运行的结果如下所示：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220527222947937.png"></p><p>可以看到，整个程序一直保持运行无法正常结束，由此可以推知t2线程对共享变量的修改t1线程是看不到的，这也符合Java内存模型工作内存和主内存的预期，但是如果我们修改t1循环内的代码后，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> test <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始值："</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> onums1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> onums2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> onums3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> onums4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"更改值："</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>则再次运行后的结果为：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220527230610609.png"></p><p>神奇的是，t1线程并没有一直在循环中，由此可以推知这种情况下t1线程一定是重新从主内存中再次获取到了共享变量，那为什么就增加了创建几个大数组就可以让线程重新去主内存刷新共享变量呢？这就涉及到工作内存的刷新时机</p><h3 id="另一个例子"><a href="#另一个例子" class="headerlink" title="另一个例子"></a>另一个例子</h3><p>首先我们来看网上有一个更为常见的例子，就是上述循环的代码块里面写一个print语句，类似这样：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"确认更改值："</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其余代码不变，最终线程t1也能够感知到flag状态的更改而结束循环，这种情况是因为<code>System.out.println</code>中是存在<code>synchronized</code>锁的，源代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">PrintStream</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">writeln</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">newLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们都知道，锁的内存语义为：</p><blockquote><p>1、线程获取锁时，JMM会把该线程对应的本地内存置为无效</p><p>2、线程释放锁时，JMM会把该线程对应的本地内存的共享变量刷新到主内存</p></blockquote><p>因此这种情况线程t1能够获取到共享变量flag的新值也不足为奇。</p><h3 id="工作内存刷新时机"><a href="#工作内存刷新时机" class="headerlink" title="工作内存刷新时机"></a>工作内存刷新时机</h3><p>多方资料搜集查验后，广泛流传的几个刷新时机总结如下：</p><blockquote><p>1、线程获取锁时</p><p>2、线程切换到其他线程，再切换回来之后</p><p>3、该线程的CPU有空闲时（或者说涉及CPU时间片轮转时），比如当前线程sleep了</p></blockquote><p>再回到第一个例子，其实最开始测试的时候new产生的数组设置为了1000，此时仍然会执行死循环，因此导致无法退出死循环的直接原因是创建的数组不够大。而对象创建的过程主要步骤为：</p><blockquote><p>类加载检查-&gt;分配内存-&gt;初始化零值-&gt;设置对象头-&gt;执行init方法</p></blockquote><p>因此，根据上述已有知识的推测，如果创建的对象数组过大，会导致这个流程耗时时间长，当前线程所持有的CPU在new对象数组的时候，<strong>相当于sleep了一个小时间</strong>，这个时间内CPU就会去主内存获取贡献变量的值刷新到工作内存</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>工作内存中的非volatile修饰的共享变量大致会在上述三种情况下去主内存重新刷新变量值，但是对于需要保证可见性的共享变量，尽可能还是用锁或者volatile进行修饰，确保每次得到的共享变量值都是最新的。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>后面发现一个有意思的现象，就是我们不是直接run代码，而是debug，在while循环内的x=1语句上打断点，如下：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220528151222672.png"></p><p>debug执行后，等待两秒再放行，发现此时可以得到flag的值为t2线程修改后的false</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220528151437543.png"></p><p>这进一步验证了当CPU并不是被完全占用的时候，会从主内存去刷新共享变量的值</p>]]></content>
      
      
      <categories>
          
          <category> Java多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工作内存 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>窗口函数</title>
      <link href="/2022/04/29/chuang-kou-han-shu/"/>
      <url>/2022/04/29/chuang-kou-han-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="一-窗口函数有什么用？"><a href="#一-窗口函数有什么用？" class="headerlink" title="一.窗口函数有什么用？"></a><strong>一.窗口函数有什么用？</strong></h3><p>在日常工作中，经常会遇到需要<strong>在每组内排名</strong>，比如下面的业务需求：</p><blockquote><p>排名问题：每个部门按业绩来排名<br>topN问题：找出每个部门排名前N的员工进行奖励</p></blockquote><p>面对这类需求，就需要使用sql的高级功能窗口函数了。</p><h3 id="二-什么是窗口函数？"><a href="#二-什么是窗口函数？" class="headerlink" title="二.什么是窗口函数？"></a><strong>二.什么是窗口函数？</strong></h3><p>窗口函数，也叫OLAP函数（Online Anallytical Processing，联机分析处理），可以对数据库数据进行实时分析处理。</p><p>窗口函数的基本语法如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">&lt;窗口函数> over (partition by &lt;用于分组的列名>                order by &lt;用于排序的列名>)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那么语法中的&lt;窗口函数&gt;都有哪些呢？</p><p>&lt;窗口函数&gt;的位置，可以放以下两种函数：</p><p>1） 专用窗口函数，包括后面要讲到的rank, dense_rank, row_number等专用窗口函数。</p><p>2） 聚合函数，如sum. avg, count, max, min等</p><p>因为窗口函数是对where或者group by子句处理后的结果进行操作，所以<strong>窗口函数原则上只能写在select子句中</strong>。</p><h3 id="三-如何使用？"><a href="#三-如何使用？" class="headerlink" title="三.如何使用？"></a><strong>三.如何使用？</strong></h3><p>接下来，就结合实例，给大家介绍几种窗口函数的用法。</p><h4 id="1-专用窗口函数rank"><a href="#1-专用窗口函数rank" class="headerlink" title="1.专用窗口函数rank"></a><strong>1.专用窗口函数rank</strong></h4><p>例如下图，是班级表中的内容</p><p><img src="https://pic2.zhimg.com/80/v2-f8c3b3deb99122d75bb506fdbea81c8d_720w.jpg"></p><p>如果我们想在每个班级内按成绩排名，得到下面的结果。</p><p><img src="https://pic3.zhimg.com/80/v2-3285d1d648de9f90864000d58847087a_720w.jpg"></p><p>以班级“1”为例，这个班级的成绩“95”排在第1位，这个班级的“83”排在第4位。上面这个结果确实按我们的要求在每个班级内，按成绩排名了。</p><p>得到上面结果的sql语句代码如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">select *,   rank() over (partition by 班级                 order by 成绩 desc) as rankingfrom 班级表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们来解释下这个sql语句里的select子句。rank是排序的函数。要求是“每个班级内按成绩排名”，这句话可以分为两部分：</p><p>1）每个班级内：按班级分组</p><p><strong>partition by用来对表分组</strong>。在这个例子中，所以我们指定了按“班级”分组（partition by 班级）<br>2）按成绩排名</p><p><strong>order by子句的功能是对分组后的结果进行排序</strong>，默认是按照升序（asc）排列。在本例中（order by 成绩 desc）是按成绩这一列排序，加了desc关键词表示降序排列。</p><p>通过下图，我们就可以理解partiition by（分组）和order by（在组内排序）的作用了。</p><p><img src="https://pic2.zhimg.com/80/v2-451c70aa24c68aa7142693fd27c85605_720w.jpg"></p><p>窗口函数具备了我们之前学过的group by子句分组的功能和order by子句排序的功能。那么，为什么还要用窗口函数呢？</p><p>这是因为，<strong>group by分组汇总后改变了表的行数，一行只有一个类别。而partiition by和rank函数不会减少原表中的行数</strong>。例如下面统计每个班级的人数。</p><p><img src="https://pic2.zhimg.com/80/v2-a9342df7f64ec7d9a52b42adcdb48341_720w.jpg"></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">相信通过这个例子，你已经明白了这个窗口函数的使用：select *,   rank() over (partition by 班级                 order by 成绩 desc) as rankingfrom 班级表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们说回来，为什么叫“窗口”函数呢？这是因为partition by分组后的结果称为“窗口”，这里的窗口不是我们家里的门窗，而是表示“范围”的意思。</p><p><strong>简单来说，窗口函数有以下功能：</strong></p><p>1）同时具有分组和排序的功能</p><p>2）不减少原表的行数</p><p>3）语法如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">&lt;窗口函数> over (partition by &lt;用于分组的列名>                order by &lt;用于排序的列名>)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-其他专业窗口函数"><a href="#2-其他专业窗口函数" class="headerlink" title="2.其他专业窗口函数"></a><strong>2.其他专业窗口函数</strong></h4><p>专用窗口函数rank, dense_rank, row_number有什么区别呢？</p><p>它们的区别我举个例子，你们一下就能看懂：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">select *,   rank() over (order by 成绩 desc) as ranking,   dense_rank() over (order by 成绩 desc) as dese_rank,   row_number() over (order by 成绩 desc) as row_numfrom 班级表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到结果：</p><p><img src="https://pic2.zhimg.com/80/v2-ad1d86f5a5b9f0ef684907b20b341099_720w.jpg"></p><p>从上面的结果可以看出：</p><blockquote><p>rank函数：这个例子中是5位，5位，5位，8位，也就是如果有并列名次的行，会占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：<strong>1，1，1</strong>，4。</p><p>dense_rank函数：这个例子中是5位，5位，5位，6位，也就是如果有并列名次的行，不占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：<strong>1，1，1</strong>，2。</p><p>row_number函数：这个例子中是5位，6位，7位，8位，也就是不考虑并列名次的情况。比如前3名是并列的名次，排名是正常的<strong>1，2，3</strong>，4。</p><p>这三个函数的区别如下：</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-7b63c571dfa285c0aa0c8f944ca89482_720w.jpg"></p><p>最后，需要强调的一点是：在上述的这三个专用窗口函数中，函数后面的括号不需要任何参数，保持()空着就可以。</p><p>现在，大家对窗口函数有一个基本了解了吗？</p><h4 id="3-聚合函数作为窗口函数"><a href="#3-聚合函数作为窗口函数" class="headerlink" title="3.聚合函数作为窗口函数"></a><strong>3.聚合函数作为窗口函数</strong></h4><p>聚和窗口函数和上面提到的专用窗口函数用法完全相同，只需要把聚合函数写在窗口函数的位置即可，但是函数后面括号里面不能为空，需要指定聚合的列名。</p><p>我们来看一下窗口函数是聚合函数时，会出来什么结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">select *,   sum(成绩) over (order by 学号) as current_sum,   avg(成绩) over (order by 学号) as current_avg,   count(成绩) over (order by 学号) as current_count,   max(成绩) over (order by 学号) as current_max,   min(成绩) over (order by 学号) as current_minfrom 班级表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到结果：</p><p><img src="https://pic2.zhimg.com/80/v2-c48f0218306f65049fcf9f98c184226d_720w.jpg"></p><p>有发现什么吗？我单独用sum举个例子：</p><p>如上图，聚合函数sum在窗口函数中，是对自身记录、及位于自身记录以上的数据进行求和的结果。比如0004号，在使用sum窗口函数后的结果，是对0001，0002，0003，0004号的成绩求和，若是0005号，则结果是0001号~0005号成绩的求和，以此类推。</p><p>不仅是sum求和，平均、计数、最大最小值，也是同理，都是针对自身记录、以及自身记录之上的所有数据进行计算，现在再结合刚才得到的结果（下图），是不是理解起来容易多了？</p><p><img src="https://pic2.zhimg.com/80/v2-c48f0218306f65049fcf9f98c184226d_720w.jpg"></p><p>比如0005号后面的聚合窗口函数结果是：学号0001~0005五人成绩的总和、平均、计数及最大最小值。</p><p>如果想要知道所有人成绩的总和、平均等聚合结果，看最后一行即可。</p><p><strong>这样使用窗口函数有什么用呢？</strong></p><p>聚合函数作为窗口函数，可以在每一行的数据里直观的看到，截止到本行数据，统计数据是多少（最大值、最小值等）。同时可以看出每一行数据，对整体统计数据的影响。</p><h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a><strong>4.注意事项</strong></h4><p>partition子句可是省略，省略就是不指定分组，结果如下，只是按成绩由高到低进行了排序：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">select *,   rank() over (order by 成绩 desc) as rankingfrom 班级表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>得到结果：</p><p><img src="https://pic1.zhimg.com/80/v2-c589fe21dd785ff5996174684cc4de84_720w.jpg"></p><p>但是，这就失去了窗口函数的功能，所以一般不要这么使用。</p><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a><strong>四.总结</strong></h3><h4 id="1-窗口函数语法"><a href="#1-窗口函数语法" class="headerlink" title="1.窗口函数语法"></a><strong>1.窗口函数语法</strong></h4><pre class="line-numbers language-text" data-language="text"><code class="language-text">&lt;窗口函数> over (partition by &lt;用于分组的列名>                order by &lt;用于排序的列名>)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>&lt;窗口函数&gt;的位置，可以放以下两种函数：</p><p>1） 专用窗口函数，比如rank, dense_rank, row_number等</p><p>2） 聚合函数，如sum. avg, count, max, min等</p><h4 id="2-窗口函数有以下功能："><a href="#2-窗口函数有以下功能：" class="headerlink" title="2.窗口函数有以下功能："></a><strong>2.窗口函数有以下功能：</strong></h4><p>1）同时具有分组（partition by）和排序（order by）的功能</p><p>2）不减少原表的行数，所以经常用来在每组内排名</p><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a><strong>3.注意事项</strong></h4><p>窗口函数原则上只能写在select子句中</p><h4 id="4-窗口函数使用场景"><a href="#4-窗口函数使用场景" class="headerlink" title="4.窗口函数使用场景"></a><strong>4.窗口函数使用场景</strong></h4><p>1）业务需求“<strong>在每组内排名”</strong>，比如：</p><blockquote><p>排名问题：每个部门按业绩来排名<br>topN问题：找出每个部门排名前N的员工进行奖励</p></blockquote><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><p><a href="https://zhuanlan.zhihu.com/p/92654574">通俗易懂的学会：SQL窗口函数 - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 窗口函数 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>水塘抽样算法</title>
      <link href="/2022/04/25/shui-tang-chou-yang-suan-fa/"/>
      <url>/2022/04/25/shui-tang-chou-yang-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="水塘抽样算法"><a href="#水塘抽样算法" class="headerlink" title="水塘抽样算法"></a>水塘抽样算法</h2><p>这个算法是在做leetcode的2022.4.25每日一题学习到的</p><blockquote><p>给你一个可能含有<strong>重复元素</strong>的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。</p><p>实现 Solution 类：  </p><ul><li>Solution(int[] nums) 用数组 nums 初始化对象。</li><li>int pick(int target) 从 nums 中选出一个满足 nums[i] == target 的随机索引 i 。如果存在多个有效的索引，则每个索引的返回概率应当相等。</li></ul></blockquote><p>最开始自己的想法就是用一个map保存num中的每个元素对应的索引，如果相同元素个数超过一个的话，就用Random函数随机选择索引。但是这种方法的空间复杂度是O(n)，如果<strong>数据量特别大</strong>的时候（即大数据环境下，这种方法可能性能不太好，故有了水塘抽样的方法。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><blockquote><p>遍历 nums，当我们第 i 次遇到值为 target 的元素时，随机从区间[0,i) 内选择一个随机的整数，如果其等于0，则将返回值置为该元素的下标，否则返回值不变。</p></blockquote><h3 id="算法正确性验证"><a href="#算法正确性验证" class="headerlink" title="算法正确性验证"></a>算法正确性验证</h3><p>设 nums 中有 k 个值为 target 的元素，该算法会保证这 k 个元素的下标成为最终返回值的概率均为 1/k，证明如下：</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220426002240562.png"></p></blockquote><p>因此，对于这个nums数组中的所有元素而言，每个元素的下标作为最终结果的概率都是一样的，故其实题目也可改为获取随机一个元素的下标。上述问题的代码可以写为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">;</span>    <span class="token class-name">Random</span> random<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Solution</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>        random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">pick</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token operator">++</span>cnt<span class="token punctuation">;</span> <span class="token comment">// 第 cnt 次遇到 target</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    ans <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算法一般化"><a href="#算法一般化" class="headerlink" title="算法一般化"></a>算法一般化</h3><p>上述题目只是选取一个元素的下标作为最终结果，假设我们要选取k个元素的下标，那这样又要怎么实现呢？</p><p>其实思路跟上面差不多，就是用一个数组记录下每个要选取元素的cnt即可，也就是说：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">pick</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> targets<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>targets<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>targets<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> targets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> target <span class="token operator">=</span> targets<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token operator">++</span>cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 第 cnt 次遇到 target</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更一般化的结论"><a href="#更一般化的结论" class="headerlink" title="更一般化的结论"></a>更一般化的结论</h3><blockquote><p>当内存无法加载全部数据时，如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等</p></blockquote><p>根据上面算法的类似思想，首先$k=1$时，我们可以看成是当第i个随机得到的数为0时，才保留第i个数的索引，也就是说，随机选择有i种可能出现的情况，只选择其中出现的一种情况，则以此可推知，当这个数据流的第i个数被保留的概率设置为**$1/i$**时，能够保证所有数据的选取概率都是1/N</p><p>这样，推及k&gt;1时，我们可以得到这样的结论：</p><blockquote><p>对于前k个数，我们都保留，对于第i（i &gt; k）个数，我们以$k/i$的概率保留这个数，并以$1/k$的概率与之前保留的k个数种的任意一个替换，则选择每一个数的概率都会是1/N</p></blockquote><p>参考代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">ReservoirSampling</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> results<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        results<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>k<span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token class-name">N</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> random <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>random<span class="token operator">&lt;</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            results<span class="token punctuation">[</span>random<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> results<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>1、<a href="https://leetcode-cn.com/problems/random-pick-index/solution/sui-ji-shu-suo-yin-by-leetcode-solution-ofsq/">随机数索引 - 随机数索引 - 力扣（LeetCode）</a></p><p>2、<a href="https://zhuanlan.zhihu.com/p/29178293">水塘抽样（Reservoir Sampling） - 知乎</a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>在2022.6.9这道leetcode 497每日一题中，也可以使用水塘抽样算法，这道题基本思路是先选中其中的一个矩形，然后再在矩形里面随机抽出一个点，其实整体思路有点像上面的一般化结论的例子。</p><p>结合来看，水塘抽样算法可以用于<strong>多层级抽取</strong>之后保证<strong>每个抽样点概率一致</strong>的问题中，基本思路就是先得到数据流的顺序或者到目前为止的数据总和等，然后判断每一个一级数据被保留的概率，然后在一级之下的二级数据用平均的随机思想抽取</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 水塘抽样 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oauth2为什么不能跳过Code获取而直接获取Token？</title>
      <link href="/2022/04/10/oauth2-wei-shi-me-bu-neng-tiao-guo-code-huo-qu-er-zhi-jie-huo-qu-token/"/>
      <url>/2022/04/10/oauth2-wei-shi-me-bu-neng-tiao-guo-code-huo-qu-er-zhi-jie-huo-qu-token/</url>
      
        <content type="html"><![CDATA[<h2 id="Oauth2为什么不能跳过Code获取而直接获取Token？"><a href="#Oauth2为什么不能跳过Code获取而直接获取Token？" class="headerlink" title="Oauth2为什么不能跳过Code获取而直接获取Token？"></a>Oauth2为什么不能跳过Code获取而直接获取Token？</h2><p>首先，我们都知道，Oauth2整体思路是，在客户端与数据存储的服务端中间添加了一个授权层，客户端不能直接访问数据存储的服务端，只能登录到授权层，将认证和授权分隔开来。客户端访问服务端存储的数据需要携带认证层返回的code。</p><p>总之，一句话，”客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p><h3 id="Oauth2的运行流程"><a href="#Oauth2的运行流程" class="headerlink" title="Oauth2的运行流程"></a>Oauth2的运行流程</h3><p><img src="https://cdn.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/bg2014051203.png" alt="OAuth运行流程"></p><p>（A）用户打开客户端以后，客户端要求用户给予授权。</p><p>（B）用户同意给予客户端授权。</p><p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p><p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p><p>（E）客户端使用令牌，向资源服务器申请获取资源。</p><p>（F）资源服务器确认令牌无误，同意向客户端开放资源</p><p>一种很常见的授权模式即为第三方登录使用的授权码模式，该模式的流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/bg2014051204.png" alt="授权码模式"></p><p>（A）用户访问客户端，后者将前者导向认证服务器。</p><p>（B）用户选择是否给予客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码code。</p><p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p><p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p><h3 id="为什么要使用code这步中间步骤"><a href="#为什么要使用code这步中间步骤" class="headerlink" title="为什么要使用code这步中间步骤"></a>为什么要使用code这步中间步骤</h3><p>说了这么多Oauth2的流程，那具体是什么原因使得我们不能直接去访问服务端得到token呢？</p><p>其实主要的原因很简单，我们来使用反证法来考虑一下。首先得注意到的是，认证服务器的返回是通过 302 重定向实现的，也就是说，返回的code值是显示在url上的，假如我们不用code，客户端请求之后直接获得访问令牌（access token），那么token将会显示在url上，中间人就很容易截获token，token的失窃风险急剧上升。</p><p>此外，我们用 code 换取 token，不需要借助用户浏览器，是由 client 后台直接访问授权服务器的，这个步骤 client 还需要发送自己的 app secret，授权服务器也需要使用这个 app secret 来验证 client 的身份</p><p>如果在用户登陆时就要返回 token，那么 client 将不得不生成一个包含自己 app secret 的授权地址，那么 client 的 app secret 任何人都可以通过浏览器url地址栏看到了，对 client 来说也不安全</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1、<a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0 - 阮一峰的网络日志</a></p><p>2、<a href="https://blog.csdn.net/weixin_39941262/article/details/110298872">token会被截取吗_OAuth2 为什么要用 code 换 token</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth2 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACID与CAP中C的区别</title>
      <link href="/2022/03/24/acid-yu-cap-zhong-c-de-qu-bie/"/>
      <url>/2022/03/24/acid-yu-cap-zhong-c-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h2><p>在关系数据库中，一个事务通常由多个 sql 语句组成。</p><p><strong>原子性</strong>（A）保证每个事务都被视为一个完整的单元，要么全成功，要么全失败。如果构成事务的某个 sql 未能完成，则整个事务失败，数据库保持事务开始之前的状态，通常通过 undo log 实现。</p><p><strong>一致性</strong>（C）确保事务只能将数据库<strong>从一种有效状态带到另一种有效状态，维护数据库不变性</strong>，例如有在有外键约束的情况下，无法从数据库中删除一条被另外一个表引用的记录。</p><p><strong>隔离性</strong>（I）是指在并发执行事务的情况下能获得和顺序执行事务相同的状态，根据具体的实现细节可以分为不同的隔离级别。</p><p><strong>持久性</strong>（D）保证一旦事务被提交，即使在系统故障的情况下它也将保持提交后的状态，通常通过 redo log 实现。</p><h2 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h2><p>随着互联网的发展，系统架构从早期单体架构慢慢演化到了分布式架构。之前关系数据库事务包含的多个 sql 语句，随着分布式系统的出现，会在<strong>多个物理节点上执行</strong>。此时便出现了全局事务。全局事务的定义是<strong>一种适用于单个服务使用多个数据源场景的事务解决方案</strong>，本质上是在分布式系统中追求一致性的处理方案</p><p>一种解决分布式环境下一致性的方法是<strong>两阶段提交</strong>。</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>分布式也从单服务访问多数据源变成了<strong>多服务访问多数据源</strong>。</p><p><strong>Consistency 一致性</strong>代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的。</p><p><strong>Availability 可用性</strong>代表系统不间断地提供服务的能力。</p><p><strong>Partition tolerance 分区容错性</strong>代表分布式环境中部分节点因网络原因而彼此失联后，系统仍能正确地提供服务的能力。</p><p>三者只能满足其二</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><blockquote><p>在分布式环境中达成一致性需要通过<strong>共识算法</strong>，分布式共识算法的基本思路就是<strong>少数服从多数</strong>。</p><p>如果说ACID的C是节点服务器的<strong>数据完整性</strong>，而CAP的一致性是分布式<strong>多服务器之间复制数据以取得这些服务器拥有同样的数据</strong>，这是一种分布式领域的一致性概念。因此两者是完全不同的概念。</p><p><strong>分布式一致性是作为分布式系统整体对外表现为一个一致性的系统，而其内部节点之间可能存在差异</strong></p><p>此时，分布式系统的一致性和之前的一致性在概念上有较大的差别，因此大家对一致性重新做了定义，将之前的一致性叫做<em>强一致性</em>，此时的一致性叫做<em>最终一致性</em>，同时也将之前的事务叫做<em>刚性事务</em>，此时的事务叫做<em>柔性事务</em>。</p></blockquote><p>还有一种形象的比喻就是，ACID的C与CAP的C的关系类似<strong>精确与一致性</strong>的关系：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/23145886.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、<a href="https://chenyuanwai.com/">ACID 的 C 和 CAP 的 C 到底什么关系</a></p><p>2、<a href="https://www.jdon.com/46956">ACID中C与CAP定理中C的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACID </tag>
            
            <tag> CAP </tag>
            
            <tag> 事务 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String字符串最大长度探究</title>
      <link href="/2022/03/21/string-zi-fu-chuan-zui-da-chang-du-tan-jiu/"/>
      <url>/2022/03/21/string-zi-fu-chuan-zui-da-chang-du-tan-jiu/</url>
      
        <content type="html"><![CDATA[<h1 id="String字符串的最大长度是多少？"><a href="#String字符串的最大长度是多少？" class="headerlink" title="String字符串的最大长度是多少？"></a>String字符串的最大长度是多少？</h1><p>在学习和开发过程中，我们能够记住int等基本数据类型的长度，但是类似String等数据的长度的讨论少之又少。那么对于 String 类型，它到底有没有长度限制呢？</p><p>很多网上的文章说，关于 String 的长度限制要从<strong>编译时限制</strong>和<strong>运行时限制</strong>两方面考虑，Java中的UTF-8编码的Unicode字符串在常量池中以CONSTANT_Utf8类型表示，其中null 值使用两个字节来表示，因此只剩下 65536－ 2 ＝ 65534个字节。确实如此吗？我们来测试一下，实践才是检验真理的唯一标准！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> test <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"ddd...dddd"</span> <span class="token comment">//这里经过复制粘贴得到65535长</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220322123929888.png"></p><p>可以看到，65535长度的字符串确实超出限制了，如果是65534的结果如下</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220331003022939.png"></p><p>此时可以成功创建字符串</p><blockquote><p>JVM规范对常量池有所限制。常量池中的每一种数据项都有自己的类型，Java中的UTF-8编码的Unicode字符串在常量池中CONSTANT_Utf8类型表示</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">CONSTANT_Utf8_info <span class="token punctuation">&#123;</span>    u1 tag<span class="token punctuation">;</span>    u2 length<span class="token punctuation">;</span>    u1 bytes<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>length 的类型是u2，u2是无符号的16位整数，因此理论上允许的的最大长度是2^16-1=65535</p></blockquote><p>但是如果我们是采用下面这两种的方式生成字符串：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">65535</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">65535</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'d'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">String</span> s <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>cs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么结果就不一样了，它们是可以跑出结果的，如下图</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220331004542833.png"></p><p>其实这样在非字符串常量的堆上生成的字符串只会受到<strong>运行期限制</strong>，此时的字符串最大长度取决于<strong>堆的大小</strong>，理论上说，如果是Integer.MAX_VALUE长度的字符串，在JDK8下占据的字节数为2*Integer.MAX_VALUE，也就是4GB。一般实际情况由于各种因素影响，会比MAX_VALUE这个值要小一点。</p><h2 id="JVM内存区域中的字符串常量池"><a href="#JVM内存区域中的字符串常量池" class="headerlink" title="JVM内存区域中的字符串常量池"></a>JVM内存区域中的字符串常量池</h2><p>其实，这个问题来源于字符串常量池在内存中的位置区域，《深入理解Java虚拟机》P46中有一句话说到：”JDK 7的HotSpot，已经把<strong>原本放在永久代的字符串常量池、静态变量等移出</strong>。”另外，在P62可以看到，<strong>字符串常量池被移动到了Java堆之中</strong>，也就是说，JDK6和JDK7的字符串常量池已经在不同位置，就如下两图所示：</p><p>JDK6:</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220322010119819.png"></p><p>JDK7:</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220322010509189.png"></p><p><del>本次实验的时候采用的是JDK8，故字符串常量池是在<strong>堆</strong>中的！！这也就说明了为什么超过65534的字符串还能够在常量池中出现。因此，此时的字符串最大长度取决于<strong>堆的大小</strong>，理论上说，如果是Integer.MAX_VALUE长度的字符串，在JDK8下占据的字节数为2*Integer.MAX_VALUE，也就是4GB。一般实际情况由于各种因素影响，会比MAX_VALUE这个值要小一点。</del></p><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>String 的长度是有限制的。在编译期间的字符串长度受到Class类文件中的CONSTANT_Utf8限制，u2是无符号的16位整数，加上null 值使用两个 字节来表示，因此只剩下 65536－ 2 ＝ 65534个字节。</p><p><del>运行期间字符串长度与字符串常量池所在位置有关，<strong>JDK7（不包括）之前</strong>字符串常量池在方法区（永久代），因此可以用-XX:MaxPerSize限制，注意这里限制的长度是给定最大内存的1/2（因为一个char占两个字节），移动到堆上，此时字符串的最大长度就只跟堆的大小有关了</del></p><p>正确的说法应该是，字符串常量池不管是在哪里<strong>都会受到编译时限制</strong>，最大长度就是65534，运行时限制主要限制的是一些在堆上生成的字符串和字符数组</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CONSTANT_Utf8_info</span> <span class="token punctuation">&#123;</span>    u1 tag<span class="token punctuation">;</span>    u2 length<span class="token punctuation">;</span>    u1 bytes<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h2><p>后来又继续稍微看了看《深入理解Java虚拟机》关于类文件结构中的常量池部分P220-221，发现书中说了CONSTANT_Utf8_info限制了字符串内容的长度，但是65535是采用<strong>UTF-8缩略编码</strong>（其中ASCII码内的字符char占用一个字节而非两个）的<strong>字节数</strong>，所以最大字节数就是最大字符串长度</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> 实践探究 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/2022/02/28/docker-chang-yong-ming-ling/"/>
      <url>/2022/02/28/docker-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="1、帮助、启动类命令"><a href="#1、帮助、启动类命令" class="headerlink" title="1、帮助、启动类命令"></a>1、帮助、启动类命令</h2><ul><li>启动docker： <code>systemctl start docker</code></li><li>停止docker： <code>systemctl stop docker</code></li><li> 重启docker： <code>systemctl restart docker</code></li><li> 查看docker状态： systemctl status docker</li><li> 开机启动： systemctl enable docker</li><li> 查看docker概要信息： docker info</li><li>查看docker总体帮助文档： <code>docker --help</code></li><li>查看docker命令帮助文档： docker [具体命令] –help</li></ul><h2 id="2、镜像命令"><a href="#2、镜像命令" class="headerlink" title="2、镜像命令"></a>2、镜像命令</h2><ul><li><p><code>docker images [参数] [镜像[:标签]]</code> <strong>查看镜像</strong></p><ul><li><code>-a</code>：显示所有镜像。</li><li><code>-q</code>：只显示 ID。</li></ul></li><li><p><code>docker search [参数]</code> <strong>搜索镜像</strong></p><ul><li><code>-f</code> / <code>--filter</code>：根据过滤条件搜索。</li></ul></li><li><p><code>docker pull [参数] 镜像名[:标签]</code> <strong>拉取镜像</strong></p><ul><li><code>-a</code>：拉取镜像的所有标签。</li><li><code>-q</code>：抑制详细输出。</li><li>默认下载最新版，指定版本的语法类似为：docker pull redis:6.0</li></ul></li><li><p><code>docker rmi [参数] 镜像 [镜像...]</code> <strong>删除镜像</strong></p><ul><li><code>-f</code>：强制删除。</li></ul></li><li><blockquote><p><code>docker run [参数] 镜像名</code> <strong>运行镜像</strong></p><ul><li><code>--name</code>：指定容器的名称，如果正在运行该名称的容器，会报错。</li><li><code>--rm</code>：用完即删除，通常用来测试。</li><li><code>-d</code>：<strong>后台方式运行</strong>。</li><li><code>-it</code>：<strong>使用交互方式运行，可以进入容器查看内容</strong>。</li><li><code>-e</code>：指定运行环境。</li><li><code>-P</code>：随机指定端口。</li><li><code>-p</code>：指定容器的端口，如：<code>-p 8080:8080</code>。还可以有以下写法：<ul><li><code>-p ip:主机端口:容器端口</code></li><li><code>-p 主机端口:容器端口</code></li><li><code>-p 容器端口</code></li></ul></li></ul><p><strong>注意</strong>：<code>docker run -d 镜像</code> 容器运行的命令<strong>如果不是那些一直挂起的命令（比如运行top，tail）</strong>，就是会<strong>自动退出的</strong>， <strong>Docker容器后台运行,就必须有一个前台进程.</strong></p></blockquote></li></ul><h2 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h2><ul><li><p><code>docker ps [参数]</code>  <strong>查看在运行的容器</strong></p><ul><li><code>-a</code>：查看所有容器（包括正在运行的和已经停止的）。</li><li><code>-n</code>：显示最近创建的容器，设置显示个数。</li><li><code>-q</code>：只显示容器的编号。</li></ul><blockquote><p>docker ps -a     查看所有容器</p></blockquote></li><li><p><strong>退出容器</strong></p><ul><li>使用 <code>exit</code> 退出，容器停止</li><li>使用 <code>Ctrl + P + Q</code> 快捷键退出，容器不停止。</li></ul></li><li><p><code>docker rm [参数] 容器 [容器...]</code> <strong>删除容器</strong></p><ul><li><code>-f</code>：强制删除。</li></ul></li><li><p><code>docker start 容器</code></p></li><li><p><code>docker restart 容器</code></p></li><li><p><code>docker stop 容器</code></p></li><li><p><code>docker kill 容器</code> <strong>强制停止</strong></p></li><li><p><code>docker inspect 容器</code> ·     <strong>查看容器内部细节</strong></p></li><li><p><code>docker exec [参数] 容器 路径</code> 进入正在运行的容器，<strong>新开启一个终端</strong></p><ul><li><code>-d</code>：后台运行。</li><li><code>-it</code>：交互模式进入。</li></ul></li><li><p><code>docker attach 容器</code> 进入容器<strong>正在执行的终端</strong>，<strong>不会</strong>启动新的进程（<code>/bin/bash</code> 是 centos 容器的默认终端）</p></li><li><p><code>docker cp 容器ID:容器内路径 目的主机路径</code> 将容器内文件复制到主机上（简单方法是数据卷技术）</p></li><li><p><code>docker stats [参数] [容器...]</code> <strong>查看Docker内存占用</strong></p><ul><li><code>-a</code>：查看所有容器的内存占用（默认只展示运行的容器）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态代理</title>
      <link href="/2022/01/26/dong-tai-dai-li/"/>
      <url>/2022/01/26/dong-tai-dai-li/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式，就是使用代理对象来代替对真实对象的访问，这样就可以在<strong>不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能</strong></p><p>举例来说，生活中有很多演员艺人之类的人，一般他们去跟外界沟通都不会直接是本人去，都是经纪人或者工作室去联络通知，这个经纪人、工作室就相当于这里的代理</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E4%BB%A3%E7%90%86.png"></p><p>代理模式大致有三种角色：</p><ul><li>Real Subject：真实类，也就是被代理类、委托类。用来真正完成业务服务功能；</li><li>Proxy：代理类。将自身的请求用 Real Subject 对应的功能来实现，代理类对象并不真正的去实现其业务功能；</li><li>Subject：定义 Real Subject 和 Proxy 角色都应该实现的接口。</li></ul><p>一个基本的 UML 图如下所示</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/uml.png"></p><p>代理主要分为两种类型：<strong>静态代理和动态代理</strong>，动态代理又有 JDK 代理和 CGLib 代理两种</p><blockquote><p>要理解静态和动态这两个含义，我们首先需要理解一下 Java 程序的运行机制:</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/640-16431885283843.webp"></p><p>首先 Java 源代码经过编译生成字节码，然后再由 JVM 经过类加载，连接，初始化成 Java 类型，可以看到字节码是关键，静态和动态的区别就在于字节码生成的时机。</p><p><strong>静态代理</strong>：由程序员创建代理类或特定工具自动生成源代码再对其编译。在编译时已经将接口，被代理类（委托类），代理类等确定下来，在<strong>程序运行前</strong>代理类的.class文件就已经存在了。</p><p><strong>动态代理</strong>：在<strong>程序运行后</strong>通过反射创建生成字节码再由 JVM 加载而成。</p></blockquote><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token comment">//定义业务接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SmsService</span> <span class="token punctuation">&#123;</span>     <span class="token class-name">String</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建一个具体的实现类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmsServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SmsService</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"send message:"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> message<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建代理类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmsProxy</span> <span class="token keyword">implements</span> <span class="token class-name">SmsService</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 将委托类注入进代理类</span>     <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token class-name">SmsProxy</span><span class="token punctuation">(</span><span class="token class-name">SmsService</span> smsService<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>smsService <span class="token operator">=</span> smsService<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>      <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 调用委托类方法之前，我们可以添加自己的操作</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"before method send()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 调用委托类方法</span>         smsService<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 调用委托类方法之后，我们同样可以添加自己的操作</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after method send()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//具体使用</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">SmsService</span> smsService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmsServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">SmsProxy</span> smsProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmsProxy</span><span class="token punctuation">(</span>smsService<span class="token punctuation">)</span><span class="token punctuation">;</span>    smsProxy<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态代理的不足之处：</p><ol><li>代理类只代理一个委托类（其实可以代理多个，但不符合单一职责原则），也就意味着如果<strong>要代理多个委托类，就要写多个代理</strong>（静态代理在编译前必须确定）</li><li>如果每个委托类的每个方法都要被织入同样的逻辑，比如说要计算每个委托类每个方法的耗时，就要在方法开始前，开始后分别织入计算时间的代码，那就算用代理类，它的方法也有<strong>无数这种重复的计算时间的代码</strong></li></ol><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>回顾静态代理，我们可以讲其执行过程抽象为：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86.png"></p><p>显而易见，代理类无非是在调用委托类方法的前后增加了一些操作。委托类的不同，也就导致代理类的不同。</p><p>那么为了做一个通用性的代理类出来，我们把调用委托类方法的这个动作抽取出来，把它<strong>封装成一个通用性的处理类</strong>，于是就有了动态代理中的 <code>InvocationHandler</code> 角色（处理类）。这个角色主要是对<strong>代理类调用委托类方法的这个动作</strong>进行<strong>统一的调用</strong></p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/66.png"></p><p>动态代理的具体使用步骤：</p><blockquote><p><strong>1）</strong>定义一个接口（Subject）</p><p><strong>2）</strong>创建一个委托类（Real Subject）实现这个接口</p><p><strong>3）</strong>创建一个处理类并实现 <code>InvocationHandler</code> 接口，重写其 <code>invoke</code> 方法（在 <code>invoke</code> 方法中利用反射机制调用委托类的方法，并自定义一些处理逻辑），并将委托类注入处理类</p><p><strong>4）</strong>创建代理对象（Proxy）：通过 <code>Proxy.newProxyInstance()</code> 创建委托类对象的代理对象。</p><p>注意到这个方法有三个参数:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span>                                         <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span>                                         <span class="token class-name">InvocationHandler</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li><strong>loader</strong>: 代理类的ClassLoader，最终读取动态生成的字节码，并转成 java.lang.Class 类的一个实例，通过此实例的 newInstance() 方法就可以创建出代理的对象</li><li><strong>interfaces</strong>: 委托类实现的接口，JDK 动态代理要实现所有的委托类的接口</li><li><strong>InvocationHandler</strong>: 委托对象所有接口方法调用都会转发到 InvocationHandler.invoke()，在 invoke() 方法里我们可以加入任何需要增强的逻辑 主要是根据委托类的接口等通过反射生成的</li></ol></blockquote><p>动态代理<strong>避免了静态代理那样的硬编码</strong>，另外所有委托类实现接口的方法都会在 Proxy 的 InvocationHandler.invoke() 中执行，这样如果要统计所有方法执行时间这样相同的逻辑，可以统一在 InvocationHandler 里写， 也就避免了静态代理那样需要在所有的方法中插入同样代码的问题</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Subject</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 委托类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span> <span class="token punctuation">&#123;</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 卖房</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"卖房"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//代理类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span><span class="token comment">// 维护一个目标对象</span>   <span class="token keyword">public</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token comment">// 为目标对象生成代理对象</span>   <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>               <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                   <span class="token annotation punctuation">@Override</span>                   <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>                       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"计算开始时间"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 执行目标对象方法</span>                       method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"计算结束时间"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                   <span class="token punctuation">&#125;</span>               <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">RealSubject</span> realSubject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>realSubject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Subject</span> subject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Subject</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span>realSubject<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>subject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       subject<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>打印结果如下<span class="token operator">:</span>计算开始时间卖房计算结束时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h3><p> 从newProxyInstance 的方法签名可以看出，JDK动态代理的一个问题是，<strong>委托类必须实现了某个代理接口</strong>，并且代理类也只能代理接口中实现的方法，为了解决这个问题，我们可以用 CGLIB 动态代理机制。</p><p>CGLIB 动态代理也提供了类似的  <strong>Enhance 类</strong>，，原理就是通过<strong>字节码技术生成一个子类</strong>，并在<strong>子类中拦截父类方法的调用</strong>，织入额外的业务逻辑，具体实现的增强逻辑写在 <code>MethodInterceptor.intercept()</code> 中，也就是说所有委托类的<strong>非 final 方法</strong>都会被方法拦截器拦截</p><p>使用示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMethodInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">&#123;</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> proxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"目标类增强前！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//注意这里的方法调用，不是用反射！！！</span>       <span class="token class-name">Object</span> object <span class="token operator">=</span> proxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"目标类增强后！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> object<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CGlibProxy</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span>       <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//设置目标类的字节码文件</span>       enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span><span class="token class-name">RealSubject</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//设置回调函数</span>       enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyMethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//这里的create方法就是正式创建代理类</span>       <span class="token class-name">RealSubject</span> proxyDog <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">RealSubject</span><span class="token punctuation">)</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//调用代理类的方法</span>       proxyDog<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>打印结果如下：目标类增强前！！！卖房目标类增强后！！！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a><strong>JDK 动态代理和 CGLIB 动态代理对比</strong></h3><p>1）JDK 动态代理是基于实现了接口的委托类，通过接口实现代理；而 CGLIB 动态代理是基于继承了委托类的子类，通过子类实现代理。</p><p>2）JDK 动态代理只能代理实现了接口的类，且只能增强接口中现有的方法；而 CGLIB 可以代理未实现任何接口的类，但不能是final的方法。</p><p>3）就二者的效率来说，大部分情况都是 JDK 动态代理的效率更高，随着 JDK 版本的升级，这个优势更加明显。</p><p>4）JDK 动态代理的拦截对象是<strong>通过反射的机制来调用被拦截方法的</strong>，CGLIB 采用了<strong>FastClass 的机制来实现对被拦截方法的调用</strong></p><blockquote><p>FastClass 机制就是<strong>对一个类的方法建立索引</strong>，通过索引来直接调用相应的方法</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>静态代理就是，对于你想要增强的委托类，我们需要新建一个代理类，这两个类实现一个同样的接口，然后将委托类注入进代理类中，在代理类的方法中调用委托类中的对应方法。这样，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</p><p>从 JVM 层面来说， 静态代理就是在编译时就将接口、委托类、代理类这些都变成了一个个实际的 <code>.class</code> 文件。</p><p>静态代理的弊端很明显，一个委托类对应一个代理类，多个委托类就需要新建多个代理类。</p></blockquote><blockquote><p>JDK 动态代理需要委托类实现一个接口，不过代理类就不需要也实现同样的接口了，但是，JDK 动态代理机制中添加了一个新的角色，那就是处理类。具体来说，我们需要新建一个处理类，然后将委托类注入处理类，另外，这个处理类需要实现 <code>InvocationHandler</code> 接口，并重写其 <code>invoke</code> 方法，在 <code>invoke</code> 方法中可以利用反射机制调用委托类的方法，并可以在其前后添加一些额外的处理逻辑。最后，我们定义一个代理类，通过 <code>Proxy.newProxyInstance()</code> 创建委托类对象的代理对象。</p><p>JDK 动态代理有一个最致命的问题是它只能代理实现了某个接口的实现类，并且代理类也只能代理接口中实现的方法，要是实现类中有自己私有的方法，而接口中没有的话，该方法就不能进行代理调用。</p><p>为了解决这个问题，我们可以用 CGLIB 动态代理机制，CGLIB（Code Generation Library）其实就是一个基于 ASM 的 Java 字节码生成框架。</p><p>解释一下什么是字节码生成框架：</p><p>一个 <code>Class</code> 类对应一个 <code>.class</code> 字节码文件，也就是说字节码文件中存储了一个类的全部信息。字节码其实是二进制文件，内容是只有 JVM 能够识别的机器码。</p><p>JVM 解析字节码文件也就是加载类的过程是这样的：JVM 读取 <code>.class</code> 字节码文件，取出二进制数据，加载到内存中，解析字节码文件内的信息，然后生成对应的 <code>Class</code> 类对象。</p><p>显然，这个过程是在编译期就发生的。</p><p>那如果我们在运行期遵循 Java 编译系统组织 <code>.class</code> 字节码文件的格式和结构，生成相应的二进制数据（这就是字节码工具做的事情），然后再把这个二进制数据加载转换成对应的类。这样，我们不就完成了在运行时动态的创建一个类吗。这个思想其实也就是动态代理的思想。</p><p>简单来说，动态代理就是通过字节码技术生成一个子类，并在子类中拦截父类方法的调用（这也就是为什么说 CGLIB 是基于继承的了），织入额外的业务逻辑。关键词就是拦截，CGLIB 引入一个新的角色方法拦截器，让其实现接口 <code>MethodInterceptor</code>，并重写 <code>intercept</code> 方法，这里的 <code>intercept</code> 用于拦截并增强委托类的方法（和 JDK 动态代理 <code>InvocationHandler</code> 中的 <code>invoke</code> 方法类似），最后，通过 <code>Enhancer.create()</code> 创建委托类对象的代理对象。</p></blockquote><p>总之，三种代理的角色分配为：</p><p>静态代理：</p><ul><li>Subject：公共接口</li><li>Real Subject：委托类</li><li>Proxy：代理类</li></ul><p>JDK 动态代理：</p><ul><li>Subject：公共接口</li><li>Real Subject：委托类</li><li>Proxy：代理类</li><li><strong>InvocationHandler</strong>：处理类，统一调用方法</li></ul><p>CGLIB 动态代理：</p><ul><li>Subject：公共接口</li><li>Real Subject：委托类</li><li>Proxy：代理类</li><li><strong>MethodInterceptor</strong>：方法拦截器，统一调用方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 代理模式 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆和栈的访问效率</title>
      <link href="/2022/01/17/dui-he-zhan-de-fang-wen-xiao-lu/"/>
      <url>/2022/01/17/dui-he-zhan-de-fang-wen-xiao-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么栈的速度比堆要快"><a href="#为什么栈的速度比堆要快" class="headerlink" title="为什么栈的速度比堆要快"></a>为什么栈的速度比堆要快</h2><p>我们都知道，堆和栈可以有两种主要的解释，一是两种常用的数据结构，二是内存中两个重要的部分。对于内存中的堆栈结构，一般来说，使用栈往往比使用堆更高效，这是为什么呢？</p><p>综合各方面的资料来看，总结大概有以下几个方面的原因：</p><blockquote><ol><li>栈有专门的寄存器（esp,ebp)，压栈和出栈的指令效率很高，对堆的访问只能是间接寻址，并且堆内存可能被OS调度在非物理内存中（虚拟内存的缺页），或是申请内存不连续，造成碎片过多等问题。</li><li>堆在分配和释放时都要调用函数（MALLOC,FREE)，分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成碎片），这些都会花费一定的时间，他们做了很多额外的工作，而栈却不需要这些。</li><li>栈中数据cpu命中率更高，满足局部性原理，且因为栈中数据一般是和代码段一起载入CPU内存，栈上的变量很大程度上会保存在寄存器中，因此访问更快。</li><li>栈是编译时系统自动分配空间，只需要简单的栈顶指针移动，而堆是动态分配（运行时分配空间），所以栈的速度快。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2022/01/14/fen-bu-shi-shi-wu/"/>
      <url>/2022/01/14/fen-bu-shi-shi-wu/</url>
      
        <content type="html"><![CDATA[<p>一个复杂的系统往往都是从一个小而简的系统发展衍化而来，为了满足日益增长的业务需求，不断的增加系统的复杂度，从单体架构逐步发展为分布式架构，而分布式系统架构的设计主要关注：高性能，高可用，高拓展</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>高可用是指系统无中断的执行功能的能了，代表了系统的可用程度，是进行系统设计时必须要遵守的准则之一。</p><p>而高可用的实现方案，无外乎就是冗余，就存储的高可用而言，问题不在于如何进行数据备份，而在于如何规避数据不一致对业务造成的影响</p><p>对于分布式系统而言，要保证分布式系统中的数据一致性就需要一种方案，可以保证数据在子系统中始终保持一致，避免业务出现问题，这种实现方案就叫做分布式事务，要么一起成功，要么一起失败，必须是一个整体性的事务</p><p><strong>举个栗子：</strong></p><p> 在电商网站中，用户对商品进行下单，需要在订单表中创建一条订单数据，同时需要在库存表中修改当前商品的剩余库存数量，两步操作一个添加，一个修改，我们一定要保证这两步操作一定同时操作成功或失败，否则业务就会出现问题</p><p><strong>建立时：</strong></p><p> 业务量不大，用户少，系统只是一个单体架构，订单表与库存表都在一个数据库中，这时可以使用mysql的本地事务保证数据一致性</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84.png"></p><p><strong>发展期：</strong></p><p> 业务发展迅速，用户量变多，单数据已经出现了性能瓶颈，按照业务纬度进行分库，分为订单库和库存库，由于跨库跨机器，mysql的本地事务不能再保证订单库和库存库的数据一致性，这时候就需要分布式事务来保证</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%88%86%E5%BA%93.png"></p><p><strong>成熟期：</strong></p><p> 业务拓展，单体架构已经满足不了需求，进而衍化成了分布式系统，这时的订单和库存已经拆分为了两个子系统提供服务，子系统间使用rpc进行通信，但是无论系统发展成什么样，我们都要保证业务不出问题，保证订单和库存的数据一致，这时候要思考下在服务之间我们应如何保证数据一致</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86.png"></p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p> 在讲解具体方案之前，有必要了解一下分布式中数据设计需要遵循的理论基础，CAP理论和BASE理论，为后面的实践铺平道路</p><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP：Consistency Availability Partition tolerance 的简写</p><ul><li><p><strong>Consistency</strong>：一致性</p><p>对某个客户端来说，读操作能够返回最新的写操作结果</p></li><li><p><strong>Availability</strong>：可用性</p><p>非故障节点在合理的时间内返回合理的响应</p></li><li><p><strong>Partition tolerance</strong>：分区容错性</p><p>当出现网络分区后，系统能够继续提供服务 </p></li></ul><p>因为分布式系统中系统肯定部署在多台机器上，无法保证网络做到100%的可靠，所以网络分区一定存在，即<strong>P一定存在</strong>；</p><p>在出现网络分区后，就出现了可用性和一致性的问题，我们必须要在这两者之间进行取舍，因此就有了两种架构：CP架构，AP架构（zookeeper就是CP架构）</p><h4 id="CP架构"><a href="#CP架构" class="headerlink" title="CP架构"></a>CP架构</h4><p>当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/CP.png"></p><ol><li>当没有出网络分区时，系统A与系统B的数据一致，X=1</li><li>将系统A的X修改为2，X=2</li><li>当出现网络分区后，系统A与系统B之间的数据同步数据失败，系统B的X=1</li><li>当客户端请求系统B时，为了保证一致性，此时系统B应拒绝服务请求，返回错误码或错误信息</li></ol><p>上面这种方式就违背了可用性的要求，只满足一致性和分区容错，即CP</p><p>CAP理论是忽略网络延迟，从系统A同步数据到系统B的网络延迟是忽略的</p><p>CP架构保证了客户端在获取数据时一定是最近的写操作，或者获取到异常信息，绝不会出现数据不一致的情况</p><h4 id="AP架构"><a href="#AP架构" class="headerlink" title="AP架构"></a>AP架构</h4><p>当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/AP.png"></p><ol><li>当没有出网络分区时，系统A与系统B的数据一致，X=1</li><li>将系统A的X修改为2，X=2</li><li>当出现网络分区后，系统A与系统B之间的数据同步数据失败，系统B的X=1</li><li>当客户端请求系统B时，为了保证可用性，此时系统B应返回旧值，X=1</li></ol><p>上面这种方式就违背了一致性的要求，只满足可用性和分区容错，即AP</p><p>CP架构保证了客户端在获取数据时无论返回的是最新值还是旧值，系统一定是可用的</p><p><strong>CAP理论关注粒度是数据，而不是整体系统设计的策略</strong></p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p> BASE理论指的是<strong>基本可用 Basically Available</strong>，<strong>软状态 Soft State</strong>，<strong>最终一致性 Eventual Consistency</strong>，核心思想是即便无法做到强一致性，但应该可以有采用适合的方式保证最终一致性</p><p>BASE：Basically Available Soft Stat Eventual Consistency的简写</p><ul><li><p>BA：Basically Available 基本可用</p><p>分布式系统在出现故障的时候，允许损失部分可用性，即<strong>保证核心可用</strong></p></li><li><p>S：Soft State 软状态</p><p>允许系统<strong>存在中间状态</strong>，而该中间状态不会影响系统整体可用性</p></li><li><p>E：Consistency 最终一致性</p><p>系统中的所有数据副本经过一定时间后，<strong>最终能够达到一致的状态</strong></p></li></ul><p>BASE理论本质上是对CAP理论的延伸</p><h2 id="分布式事务协议"><a href="#分布式事务协议" class="headerlink" title="分布式事务协议"></a>分布式事务协议</h2><p> 前提：在单体架构中，事务的保证有mysql实现，不用我们实现，当单个数据库的性能出现瓶颈的时候，对数据库进行分表分库处理，按业务纬度将订单和库存的表分为两个库，订单库和库存库</p><h3 id="X-Open-XA-协议"><a href="#X-Open-XA-协议" class="headerlink" title="X/Open XA 协议"></a>X/Open XA 协议</h3><p>XA是一个分布式事务协议，由Tuxedo提出。XA规范主要定义了（全局）事务管理器（Transaction Manager）和（局部）资源管理器（Resource Manager）之间的接口。XA接口是双向的系统接口，在事务管理器Transaction Manager）以及一个或多个资源管理器（Resource Manager）之间形成通信桥梁</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/XA.png"></p><p>XA协议采用<strong>两阶段提交</strong>方式来管理分布式事务。XA接口提供资源管理器与事务管理器之间进行通信的标准接口</p><h3 id="2PC-二阶段提交-协议"><a href="#2PC-二阶段提交-协议" class="headerlink" title="2PC 二阶段提交 协议"></a>2PC 二阶段提交 协议</h3><p> 二阶段提交（Two-phase Commit），是指为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol)。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个<strong>作为协调者的组件</strong>来统一掌控所有节点(称作<strong>参与者</strong>)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，二阶段提交的算法思路可以概括为： <strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作</strong></p><p>二阶段提交算法的成立基于以下假设：</p><ol><li>该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)。且节点之间可以进行网络通信。</li><li>所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复</li></ol><p>二阶段提交分为两阶段：第一阶段：投票阶段，第二阶段：提交阶段</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/2pc.jpg"></p><p><strong>投票阶段 Prepares</strong></p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/2pc-1.png"></p><ol><li>协调者向所有参与者询问是否可以执行提交操作，并开始等待各参与者的响应</li><li>参与者执行事务操作，如果执行成功就返回Yes响应，如果执行失败就返回No响应</li><li>如果协调者接受参与者响应超时，也会认为执行事务操作失败</li></ol><p><strong>提交阶段 commit</strong></p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/2pc-2.png"></p><ol><li>如果第一阶段中所有参与者都返回yes响应，协调者向所有参与者发出提交请求，所有参与者提交事务</li><li>如果第一阶段中有一个或者多个参与者返回no响应，协调者向所有参与者发出回滚请求，所有参与者进行回滚操作</li></ol><p>二阶段提交优点：尽量保证了数据的强一致，但不是100%一致</p><p>缺点：</p><ul><li><p><strong>单点故障</strong></p><p>由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞，尤其时在第二阶段，协调者发生故障，那么所有的参与者都处于锁定事务资源的状态中，而无法继续完成事务操作</p></li><li><p><strong>同步阻塞</strong></p><p>由于所有节点在执行操作时都是同步阻塞的，当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态</p></li><li><p><strong>数据不一致</strong></p><p>在第二阶段中，当协调者想参与者发送提交事务请求之后，发生了局部网络异常或者在发送提交事务请求过程中协调者发生了故障，这会导致只有一部分参与者接收到了提交事务请求。而在这部分参与者接到提交事务请求之后就会执行提交事务操作。但是其他部分未接收到提交事务请求的参与者则无法提交事务。从而导致分布式系统中的数据不一致</p></li></ul><p><strong>二阶段提交的问题</strong></p><p> 如果协调者在第二阶段<strong>发送提交请求之后挂掉</strong>，而<strong>唯一接受到这条消息的参与者执行之后也挂掉了</strong>，即使协调者通过选举协议产生了新的协调者并通知其他参与者进行提交或回滚操作的话，都可能会与这个已经执行的参与者执行的操作不一样，<strong>当这个挂掉的参与者恢复之后，就会产生数据不一致的问题</strong></p><h3 id="3PC-三阶段提交-协议"><a href="#3PC-三阶段提交-协议" class="headerlink" title="3PC 三阶段提交 协议"></a>3PC 三阶段提交 协议</h3><p> 三阶段提交（Three-phase commit），三阶段提交是为解决两阶段提交协议|的缺点而设计的。 与两阶段提交不同的是，三阶段提交是<strong>“非阻塞”协议</strong>。三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，使得原先在两阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决</p><p>三阶段提交的三个阶段：CanCommit，PreCommit，DoCommit三个阶段</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/3pc.jpg"></p><p><strong>询问阶段 CanCommit</strong></p><p>协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应</p><p><strong>准备阶段 PreCommit</strong></p><p>协调者根据参与者在<strong>询问阶段</strong>的响应判断是否执行事务还是中断事务</p><ul><li>如果所有参与者都返回Yes，则执行事务</li><li>如果参与者有一个或多个参与者返回No或者超时，则中断事务</li></ul><p>参与者执行完操作之后返回ACK响应，同时开始等待最终指令</p><p><strong>提交阶段 DoCommit</strong></p><p>协调者根据参与者在<strong>准备阶段</strong>的响应判断是否执行事务还是中断事务</p><ul><li>如果所有参与者都返回正确的ACK响应，则提交事务</li><li>如果参与者有一个或多个参与者收到错误的ACK响应或者超时，则中断事务</li><li>如果参与者无法及时接收到来自协调者的提交或者中断事务请求时，会在<strong>等待超时之后，会继续进行事务提交</strong></li></ul><p>协调者收到所有参与者的ACK响应，完成事务</p><p><strong>解决二阶段提交时的问题</strong></p><p> 在三阶段提交中，如果在第三阶段协调者发送提交请求之后挂掉，并且唯一的接受的参与者执行提交操作之后也挂掉了，这时协调者通过选举协议产生了新的协调者，在二阶段提交时存在的问题就是新的协调者不确定已经执行过事务的参与者是执行的提交事务还是中断事务，但是在三阶段提交时，肯定<strong>得到了第二阶段的再次确认，那么第二阶段必然是已经正确的执行了事务操作</strong>，只等待提交事务了，所以新的协调者可以从第二阶段中分析出应该执行的操作，进行提交或者中断事务操作，这样即使挂掉的参与者恢复过来，数据也是一致的。</p><p> 所以，三阶段提交解决了二阶段提交中存在的由于协调者和参与者同时挂掉可能导致的数据一致性问题和单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行提交事务，而不会一直持有事务资源并处于阻塞状态。</p><p><strong>三阶段提交的问题</strong></p><p> 在<strong>提交阶段</strong>如果发送的是<strong>中断事务请求</strong>，但是由于网络问题，导致部分参与者没有接到请求，那么参与者会在等待超时之后执行提交事务操作，<strong>这样这些由于网络问题导致提交事务的参与者的数据就与接受到中断事务请求的参与者存在数据不一致的问题</strong>。</p><blockquote><p> <strong>所以无论是2PC还是3PC都不能保证分布式系统中的数据100%一致</strong></p><p>而且3PC 没有找到具体的实现，所以 3PC 应该只是纯的理论上的东西，而且可以看到相比于 2PC 它是做了一些努力但是效果甚微</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="强一致性分布式事务"><a href="#强一致性分布式事务" class="headerlink" title="强一致性分布式事务"></a>强一致性分布式事务</h3><p><strong>单体架构多数据源</strong>，在业务开发中，肯定是先执行对订单库的操作，但是不提交事务，再执行对库存库的操作，也不提交事务，如果两个操作都成功，在一起提交事务，如果有一个操作失败，则两个都进行回滚</p><h4 id="基于2PC-XA协议实现的JTA"><a href="#基于2PC-XA协议实现的JTA" class="headerlink" title="基于2PC/XA协议实现的JTA"></a>基于2PC/XA协议实现的JTA</h4><p>我们已经知道了2PC和XA协议的原理，而JTA是java规范，是XA在java上的实现</p><p>JTA(Java Transaction Manager) :</p><ol><li>TransactionManager : 常用方法,可以开启,回滚,获取事务. begin(),rollback()…</li><li>XAResouce : 资源管理,通过Session来进行事务管理,commit(xid)…</li><li>XID : 每一个事务都分配一个特定的XID</li></ol><p>JTA主要的原理是二阶段提交，当整个业务完成了之后只是第一阶段提交，在第二阶段提交之前会检查其他所有事务是否已经提交，如果前面出现了错误或是没有提交，那么第二阶段就不会提交，而是直接回滚，这样所有的事务都会做回滚操作</p><p>基于JTA这种方案实现分布式事务的强一致性</p><p><strong>JTA的特点：</strong></p><ul><li>基于两阶段提交，有可能会出现数据不一致的情况</li><li>事务时间过长，阻塞</li><li>性能低，吞吐量低</li></ul><p><strong>实现</strong>可以使用基于JTA实现的jar包<strong>Atomikos</strong> <em>使用例子可以自己百度一下</em></p><p> 正常架构设计中是否应该出现这种跨库的操作，我觉得是不应该的，如果过按业务拆分将数据源进行分库，我们应该同时将服务也拆分出去才合适，应遵循一个系统只操作一个数据源（主从没关系），避免后续可能会出现的多个系统调用一个数据源的情况</p><h3 id="最终一致性分布式事务方案（柔性事务）"><a href="#最终一致性分布式事务方案（柔性事务）" class="headerlink" title="最终一致性分布式事务方案（柔性事务）"></a>最终一致性分布式事务方案（柔性事务）</h3><p>JTA方案适用于单体架构多数据源时实现分布式事务，但对于微服务间的分布式事务就无能为力了，我们需要使用其他的方案实现分布式事务</p><h4 id="1、本地消息表"><a href="#1、本地消息表" class="headerlink" title="1、本地消息表"></a>1、本地消息表</h4><p>本地消息表的核心思想是<strong>将分布式事务拆分成本地事务进行处理</strong></p><p>以本文中例子，在订单系统新增一条消息表，<strong>将新增订单和新增消息放到一个事务里完成</strong>，然后通过轮询的方式去查询消息表，将消息推送到mq，库存系统去消费mq</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.png"></p><p><strong>执行流程：</strong></p><ol><li>订单系统，添加一条订单和一条消息，在一个事务里提交</li><li>订单系统，使用<strong>定时任务轮询</strong>查询状态为<strong>未同步</strong>的消息表，发送到mq，如果发送失败，就重试发送</li><li>库存系统，接收mq消息，修改库存表，需要保证幂等操作</li><li>如果修改成功，调用rpc接口修改订单系统消息表的状态为已完成或者直接删除这条消息</li><li>如果修改失败，可以不做处理，等待重试</li></ol><p>订单系统中的消息有可能由于业务问题会一直重复发送，所以为了避免这种情况可以<strong>记录一下发送次数</strong>，当达到次数限制之后报警，人工接入处理；库存系统需要保证幂等，避免同一条消息被多次消费造成数据一致；</p><p>本地消息表这种方案实现了最终一致性，需要在业务系统里增加消息表，业务逻辑中多一次插入的DB操作，所以性能会有损耗，而且最终一致性的间隔主要有定时任务的间隔时间决定</p><h4 id="2、MQ消息事务"><a href="#2、MQ消息事务" class="headerlink" title="2、MQ消息事务"></a>2、MQ消息事务</h4><p>消息事务的原理是将两个事务通过<strong>消息中间件进行异步解耦</strong></p><p>订单系统执行自己的本地事务，并发送mq消息，库存系统接收消息，执行自己的本地事务，乍一看，好像跟本地消息表的实现方案类似，只是省去了对本地消息表的操作和轮询发送mq的操作，但实际上两种方案的实现是不一样的</p><p>消息事务一定要保证业务操作与消息发送的一致性，如果业务操作成功，这条消息也一定投递成功</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E6%B6%88%E6%81%AF%E4%BA%8B%E5%8A%A1.jpg"></p><p>消息事务依赖于消息中间件的事务消息，基于消息中间件的二阶段提交实现的，RocketMQ就支持事务消息</p><p><strong>执行流程：</strong></p><ol><li>发送<strong>prepare消息</strong>到消息中间件</li><li>发送成功后，执行本地事务</li><li>如果事务执行成功，则commit，消息中间件将消息下发至消费端</li><li>如果事务执行失败，则回滚，消息中间件将这条prepare消息删除</li><li>消费端接收到消息进行消费，如果消费失败，则不断重试</li></ol><p>这种方案也是实现了最终一致性，对比本地消息表实现方案，不需要再建消息表，不再依赖本地数据库事务了，所以这种方案更适用于高并发的场景</p><h4 id="3、最大努力通知"><a href="#3、最大努力通知" class="headerlink" title="3、最大努力通知"></a>3、最大努力通知</h4><p>最大努力通知相比前两种方案实现简单，适用于一些<strong>最终一致性要求较低</strong>的业务，比如支付通知，短信通知这种业务</p><p>以支付通知为例，业务系统调用支付平台进行支付，支付平台进行支付，进行操作支付之后支付平台会尽量去通知业务系统支付操作是否成功，但是会有一个最大通知次数，如果超过这个次数后还是通知失败，就不再通知，业务系统自行调用支付平台提供一个查询接口，供业务系统进行查询支付操作是否成功</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5.png"></p><p><strong>执行流程：</strong></p><ol><li>业务系统调用支付平台支付接口， 并在本地进行记录，支付状态为支付中</li><li>支付平台进行支付操作之后，无论成功还是失败，都需要给业务系统一个结果通知</li><li>如果通知一直失败则根据重试规则进行重试，达到最大通知次数后，不在通知</li><li>支付平台提供查询订单支付操作结果接口</li><li>业务系统根据一定业务规则去支付平台查询支付结果</li></ol><p>这种方案也是实现了最终一致性</p><h4 id="4、补偿事务TCC"><a href="#4、补偿事务TCC" class="headerlink" title="4、补偿事务TCC"></a>4、补偿事务TCC</h4><p>TCC Try-Confirm-Cancel的简称，针对每个操作，都需要有一个其对应的确认和取消操作，当操作成功时调用确认操作，当操作失败时调用取消操作，类似于二阶段提交，只不过是这里的提交和回滚是针对业务上的，所以基于TCC实现的分布式事务也可以看做是对业务的一种补偿机制</p><p>TCC的三阶段：</p><ol><li><strong>Try 阶段</strong>：对业务系统做检测及资源预留</li><li><strong>Confirm 阶段</strong>：对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功</li><li><strong>Cancel 阶段</strong>：在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放</li></ol><p>在try阶段，是对业务系统进行检查及资源预览，比如订单和存储操作，需要检查库存剩余数量是否够用，并进行预留，预留操作的话就是新建一个可用库存数量字段，Try阶段操作是对这个可用库存数量进行操作</p><p>比如下一个订单减一个库存:</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/TCC.png"></p><p><strong>执行流程：</strong></p><ol><li>Try阶段：订单系统将当前订单状态设置为支付中，库存系统校验当前剩余库存数量是否大于1，然后将可用库存数量设置为库存剩余数量-1，</li><li>如果Try阶段执行成功，执行Confirm 阶段，将订单状态修改为支付成功，库存剩余数量修改为可用库存数量</li><li>如果Try阶段执行失败，执行Cancel 阶段，将订单状态修改为支付失败，可用库存数量修改为库存剩余数量</li></ol><p>基于TCC实现分布式事务，代码逻辑想对复杂一些，需要将原来的接口的逻辑拆分为：try，confirm ，cancel 三个接口的逻辑</p><p>基于TCC实现的分布式事务框架：ByteTCC，tcc-transaction</p><p>ByteTCC：<a href="https://github.com/liuyangming/ByteTCC">https://github.com/liuyangming/ByteTCC</a></p><p>tcc-transaction：<a href="https://github.com/changmingxie/tcc-transaction">https://github.com/changmingxie/tcc-transaction</a></p><hr><p>转载自：<a href="https://chenmingyu.top/distributed-transaction/">https://chenmingyu.top/distributed-transaction/</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原地哈希</title>
      <link href="/2021/12/26/yuan-di-ha-xi/"/>
      <url>/2021/12/26/yuan-di-ha-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>假设有一个长度$n$的数组，所有数字都在 $0～ n-1$ 的范围内。数组中某些数字可能是重复的，这时要我们找出数组中其中一个重复的数字，且时间复杂度 $O(n)$，空间复杂度为常数，此时应该怎么实现呢？</p></blockquote><hr><p>一般而言，对于这样的问题，通常想法是<strong>排序</strong>或者用一个<strong>Map</strong>进行存储，但是这样都会违背时间或空间复杂度的要求，所以出现了<strong>”原地哈希“</strong>的思想</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>容易知道，对于长度$n$的数组，所有数字都在 $0～ n-1$ 的范围内时，如果没有重复元素，那么数组的索引和值将会是<strong>一对一</strong>的关系。也就是说，<strong>重复</strong>的元素导致了<strong>一对多</strong>的映射关系。</p><p>因此，可以遍历数组，将索引和值进行尽可能多的一一对应映射，即使得 $nums[i] = i$。这样，相当于在<strong>原数组</strong>上进行了一个Map映射，也就是原地哈希名称的由来。</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%8E%9F%E5%9C%B0hash.png"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>由上面的算法思路，我们可以知道，如果数组索引和值的映射关系并非一一对应时，运用上述算法我们便可以推广到找数组中重复或缺失的元素</p><blockquote><p>假设一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p></blockquote><p>上述题目中对于每一个索引 $i$，经过元素换位后，索引$i$对应的正整数值 $i+1$ 若出现在数组中，一定已经换位到索引$i$处，其余的索引值要么为非正数，要么大于数组长度$n$。</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C2.png"></p><p>总之，找到第一个 $nums[j]≠ j+1$ 位置处即为所要找的数组中最小的未出现过的正整数对应的索引，对应的数值为$j+1$</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> n <span class="token operator">||</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//此时也就是这n个数正好是1~n，所以最小未出现的正整数即为n+1</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原地hash </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>try中有return语句，finally还会执行吗？</title>
      <link href="/2021/11/26/try-zhong-you-return-yu-ju-finally-huan-hui-zhi-xing-ma/"/>
      <url>/2021/11/26/try-zhong-you-return-yu-ju-finally-huan-hui-zhi-xing-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="try中有return语句，finally还会执行吗？"><a href="#try中有return语句，finally还会执行吗？" class="headerlink" title="try中有return语句，finally还会执行吗？"></a>try中有return语句，finally还会执行吗？</h2><blockquote><p><strong>先说结论，是可以执行的</strong></p></blockquote><p>我们来看看实际的实验结果</p><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><p>假设我们有这样一个代码块：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token operator">++</span>x<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你们认为会执行打印语句么？</p><p>没错，这个代码块是会执行finally里面的打印语句的，结果就如下所示：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220331231628652.png"></p><h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><p>现在我们稍微改改上面的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token operator">++</span>x<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token comment">//这里是在返回后的主函数内打印</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们不在finally里面打印，而是返回到主函数后再打印，那么结果是是什么呢？</p><p>我想应该有很多读者和我最初的想法一样：“既然finally语句会执行，那么最后返回的x值当然是3了呀！”如果是这样的想法，那么恭喜你，你也回答错了，其实这段代码打印的结果是2</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220331232347622.png"></p><p>为什么返回到主程序的值会是2呢？其实在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10.2.5">JVM规范</a>里面明确说明了这种情况：</p><blockquote><p> If the <code>try</code> clause executes a <em>return</em>, the compiled code does the following:</p><ol><li>Saves the return value (if any) in a local variable.</li><li>Executes a <em>jsr</em> to the code for the <code>finally</code> clause.</li><li>Upon return from the <code>finally</code> clause, returns the value saved in the local variable.</li></ol></blockquote><p>也就是说，try中有return的时候的执行顺序大概如下：</p><blockquote><p>1、先把要return的x值保存下来</p><p>2、执行finally语句块内的代码</p><p>3、返回第一步保存下来的x值</p></blockquote><p>这么一看，也就清晰明白了为什么上面的返回值为2</p><p>还有一种特别的情况，假设finally语句块内又有一个return语句:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token operator">++</span>x<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token comment">//这里是在返回后的主函数内打印</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么此时的结果又是什么呢？</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220401002744626.png"></p><p>可以看到，此时的打印结果返回了3，也就是说，真正的返回语句是finally语句块内的return，前面try语句块中的return被丢弃了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从上面的实验来看，可以得到相关的结论为：</p><blockquote><ol><li>try中有return, 会先将值暂存，无论finally语句中对该值做什么处理，最终返回的都是try语句中的暂存值。</li><li>当try与finally语句中均有return语句，会忽略try中return，真正的返回值为finally里面的return。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> try_catch </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用快捷键</title>
      <link href="/2021/11/15/idea-chang-yong-de-yi-xie-kuai-jie-jian/"/>
      <url>/2021/11/15/idea-chang-yong-de-yi-xie-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h2><p>IDEA有很多快捷键可以帮助我们快速开发，但是有时候我们经常会忘，特别是有一段时间不用了之后，本文记录一些自己用过且比较容易忘掉的的快捷键以备以后再次使用时快速查找</p><h3 id="一、Ctrl-快捷键"><a href="#一、Ctrl-快捷键" class="headerlink" title="一、Ctrl 快捷键"></a>一、Ctrl 快捷键</h3><blockquote><p>Ctrl + R    在当前文件进行文本替换<br>Ctrl + Y    删除光标所在行 或 删除选中的行<br>Ctrl + D    复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面<br>Ctrl + W    递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围<br>Ctrl + E    显示最近打开的文件记录列表<br>Ctrl + N    根据输入的 名/类名 查找类文件<br>Ctrl + G    在当前文件跳转到指定行处<br>Ctrl + P    方法参数提示显示</p><p>Ctrl + Q    在方法上显示注释的显示文档内容<br>Ctrl + U    前往当前光标所在的方法的父类的方法 / 接口定义<br>Ctrl + B    等效于 Ctrl + 左键单击<br>Ctrl + H    显示当前类的层次结构<br>Ctrl + +    展开代码<br>Ctrl + -    折叠代码</p><p>Ctrl + End  跳到文件尾<br>Ctrl + Home 跳到文件头<br>Ctrl + Space       基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl +逗号<br>Ctrl + Delete      删除光标后面的单词或是中文句<br>Ctrl +BackSpace    删除光标前面的单词或是中文句<br>Ctrl + 左方向键     光标跳转到当前单词 / 中文句的左侧开头位置<br>Ctrl + 右方向键     光标跳转到当前单词 / 中文句的右侧开头位置<br>Ctrl + 前方向键     等效于鼠标滚轮向前效果<br>Ctrl + 后方向键     等效于鼠标滚轮向后效果<br>Ctrl +1,2,3…9    定位到对应数值的书签位置 </p></blockquote><h3 id="二、Alt-快捷键"><a href="#二、Alt-快捷键" class="headerlink" title="二、Alt 快捷键"></a>二、Alt 快捷键</h3><blockquote><p>Alt + `   显示版本控制常用操作菜单弹出层<br>Alt + Q   弹出一个提示，显示当前类的声明 / 上下文信息<br>Alt + F7  查找光标所在的方法 / 变量 / 类被调用的地方<br>Alt + F8  在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果<br>Alt + Home   定位 / 显示到当前文件的 Navigation Bar<br>Alt + Enter  IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同<br>Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 </p><p>Alt + 左方向键     切换当前已打开的窗口中的子视图，比如 Debug 窗口中有 Output、Debugger 等子视图，用此快捷键就可以在子视图中切换<br>Alt + 右方向键     按切换当前已打开的窗口中的子视图，比如 Debug 窗口中有 Output、Debugger 等子视图，用此快捷键就可以在子视图中切换<br>Alt + 前方向键     当前光标跳转到当前文件的前一个方法名位置<br>Alt + 后方向键     当前光标跳转到当前文件的后一个方法名位置 </p></blockquote><h3 id="三、Shift-快捷键"><a href="#三、Shift-快捷键" class="headerlink" title="三、Shift 快捷键"></a>三、Shift 快捷键</h3><blockquote><p>Shift + F4   对当前打开的文件，使用新 Windows 窗口打开，旧窗口保留<br>Shift + F6   对文件 / 文件夹 重命名<br>Shift + F11  弹出书签显示层<br>Shift + 左/右方向键  从光标当前位置往右选中<br>Shift + End    选中光标到当前行尾位置<br>Shift + Home   选中光标到当前行头位置<br>Shift + 左键单击      在打开的文件名上按此快捷键，可以关闭当前打开文件<br>Shift + 滚轮前后滚动   当前文件的<strong>横向</strong>滚动轴滚动 </p></blockquote><h3 id="四、Ctrl-Alt-快捷键"><a href="#四、Ctrl-Alt-快捷键" class="headerlink" title="四、Ctrl + Alt 快捷键"></a>四、Ctrl + Alt 快捷键</h3><blockquote><p>Ctrl + Alt + L   格式化代码，可以对当前文件和整个包目录使用<br>Ctrl + Alt + O   优化导入的类，可以对当前文件和整个包目录使用<br>Ctrl + Alt + T   对选中的代码弹出环绕选项弹出层 （try catch)<br>Ctrl + Alt + H   调用层次<br>Ctrl + Alt + B   在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口<br>Ctrl + Alt + F7  显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</p><p>Ctrl + Alt + F11 切换全屏模式<br>Ctrl + Alt + Enter   光标所在行<strong>上方</strong>空出一行，光标定位到新行<br>Ctrl + Alt + 左方向键    退回到上一个操作的地方<br>Ctrl + Alt + 右方向键    前进到上一个操作的地方<br>Ctrl + Alt + 前方向键    在查找模式下，跳到上个查找的文件<br>Ctrl + Alt + 后方向键    在查找模式下，跳到下个查找的文件</p></blockquote><h3 id="五、Ctrl-Shift-快捷键"><a href="#五、Ctrl-Shift-快捷键" class="headerlink" title="五、Ctrl + Shift 快捷键"></a>五、Ctrl + Shift 快捷键</h3><blockquote><p>Ctrl + Shift + F  根据输入内容查找整个项目 或 指定目录内文件<br>Ctrl + Shift + R  根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件<br>Ctrl + Shift + J  自动将下一行合并到当前行末尾<br>Ctrl + Shift + Z  取消撤销<br>Ctrl + Shift + W  递进式<strong>取消</strong>选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）<br>Ctrl + Shift + N  通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠<br>Ctrl + Shift + U  对选中的代码进行大 / 小写轮流转换<br>Ctrl + Shift + T  对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</p><p>Ctrl + Shift + C  复制当前文件磁盘路径到剪贴板<br>Ctrl + Shift + V  弹出缓存的最近拷贝的内容管理器弹出层<br>Ctrl + Shift + I  快速查看光标所在的方法 或 类的定义<br>Ctrl + Shift + [  选中从光标所在位置到它的顶部中括号位置<br>Ctrl + Shift + ]  选中从光标所在位置到它的底部中括号位置<br>Ctrl + Shift + +  展开所有代码<br>Ctrl + Shift + -  折叠所有代码 </p><p>Ctrl + Shift + 前方向键    光标放在方法名上，将方法移动到上一个方法前面，调整方法排序<br>Ctrl + Shift + 后方向键    光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</p></blockquote><h3 id="六、Alt-Shift-快捷键"><a href="#六、Alt-Shift-快捷键" class="headerlink" title="六、Alt + Shift 快捷键"></a>六、Alt + Shift 快捷键</h3><blockquote><p>Alt + Shift + 前方向键  移动光标所在行向上移动<br>Alt + Shift + 后方向键  移动光标所在行向下移动 </p></blockquote><h3 id="七、其他快捷键"><a href="#七、其他快捷键" class="headerlink" title="七、其他快捷键"></a>七、其他快捷键</h3><blockquote><p>F2   跳转到下一个高亮错误 或 警告位置<br>F11  添加书签<br>连按两次Shift  弹出 Search Everywhere 弹出层</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双亲委派机制</title>
      <link href="/2021/11/09/shuang-qin-wei-pai-ji-zhi/"/>
      <url>/2021/11/09/shuang-qin-wei-pai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>从Java虚拟机的角度上讲，其实只存在两种不同的类加载器，一是启动类加载器（<code>Bootstrap ClassLoader</code>），其为虚拟机的一部分，二是其他所有的类加载器。</p><p>但是从开发人员的角度上说，类加载器可以分得更为细致。</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/image-20220109200810277.png"></p><p>一般认为上一层加载器是下一层加载器的父加载器，因而，除了<code>BootstrapClassLoader</code>之外，所有的加载器都是有父加载器的。</p><h3 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></h3><ul><li><p>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</p></li><li><p>它用来加载<strong>Java的核心库</strong>（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</p></li><li><p>并不继承自ava.lang.ClassLoader，没有父加载器。</p></li><li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p></li><li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为<strong>java、javax、sun</strong>等开头的类</p></li></ul><h3 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a><strong>扩展类加载器（Extension ClassLoader）</strong></h3><ul><li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p></li><li><p>派生于ClassLoader类</p></li><li><p>父类加载器为启动类加载器</p></li><li><p>从<strong>java.ext.dirs</strong>系统属性所指定的目录中加载类库，或从JDK的安装目录的<strong>jre/1ib/ext</strong>子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p></li></ul><h3 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></h3><ul><li><p>java语言编写，由sun.misc.LaunchersAppClassLoader实现</p></li><li><p>派生于ClassLoader类</p></li><li><p>父类加载器为扩展类加载器</p></li><li><p>它负责加载<strong>环境变量classpath或系统属性java.class.path指定路径下的类库</strong></p></li><li><p>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</p></li><li><p>通过ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</p></li></ul><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>主要用途：隔离加载类、修改类加载的方式、扩展加载源、防止源码泄漏</p><blockquote><p>补充：<strong>获取ClassLoader的途径</strong></p><ol><li><p>获取当前ClassLoader  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">clazz<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取当前线程上下文的ClassLoader  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取系统的ClassLoader  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取调用者的ClassLoader  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getCallerClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></blockquote><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><blockquote><p>定义：</p><p><strong>当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。</strong></p></blockquote><p><strong>好处</strong>：</p><p>1、因为类加载器之间有严格的层次关系，那么<strong>Java的类也随之具备了一种带优先级的层次关系</strong>。</p><p>2、<strong>通过双亲委派的方式，还保证了安全性</strong>（因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Object，那么这个类是不会被随意替换的，可以避免有人自定义一个有破坏功能的java.lang.Object被加载，也就是<strong>沙箱安全机制</strong>）</p><blockquote><p><strong>“父子加载器”之间的关系是继承吗？</strong></p><p>不是！！</p><p>类加载器之间的父子关系一般<strong>不会以继承（Inheritance）的关系</strong>来实现，而是都使用<strong>组合（Composition）关系</strong>来复用父加载器的代码的</p></blockquote><h2 id="双亲委派是怎么实现的？"><a href="#双亲委派是怎么实现的？" class="headerlink" title="双亲委派是怎么实现的？"></a><strong>双亲委派是怎么实现的？</strong></h2><p>在java.lang.ClassLoader的loadClass()方法的短短数十行之中有很清晰地描述</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// First, check if the class has already been loaded</span>                <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                            c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// ClassNotFoundException thrown if class not found</span>                        <span class="token comment">// from the non-null parent class loader</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// If still not found, then invoke findClass in order</span>                        <span class="token comment">// to find the class.</span>                        c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> c<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体过程从代码不难看出：</p><p>1、先检查类是否已经被加载过</p><p>2、若没有加载则调用父加载器的<code>loadClass()</code>方法进行加载</p><p>3、若父加载器为空则默认使用启动类加载器作为父加载器。</p><p>4、如果父类加载失败，抛出ClassNotFoundException异常后，再调用自定义的<code>findClass()</code>方法进行加载。</p><blockquote><p>如果我们自定义的类加载器不希望破坏双亲委派机制，那么只需要重写 <code>ClassLoader</code> 的 <code>findClass</code> 方法即可，在这个方法中，我们可以自定义类的查找顺序，根据某种规则查找类。</p></blockquote><h2 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h2><p>从上面可以看到，因为他的双亲委派过程都是在<code>loadClass()</code>方法中实现的，那么<strong>想要破坏这种机制，那么就自定义一个类加载器，重写其中的<code>loadClass()</code>方法，使其不进行双亲委派即可</strong></p><blockquote><p><strong>双亲委派被破坏的例子</strong>：</p><p><strong>1、双亲委派出现之前。</strong></p><p>由于双亲委派模型是在JDK1.2之后才被引入的，而在这之前已经有用户自定义类加载器在用了。所以，这些是没有遵守双亲委派原则的。</p><p><strong>2、JNDI、JDBC等需要加载SPI接口实现类的情况。</strong></p><p>这种情况是基础类型想要调用回用户的代码（而根据双亲委派机制，越基础的类由越上层的加载器进行加载） =&gt; 引入线程上下文类加载器（Thread Context ClassLoader）</p><p><strong>3、为了实现热插拔热部署工具。</strong></p><p>为了让代码动态生效而无需重启，实现方式时把模块连同类加载器一起换掉就实现了代码的热替换。</p><p><strong>4、Tomcat等web容器的出现。</strong></p><p><strong>5、OSGI、Jigsaw等模块化技术的应用。</strong></p></blockquote><p>下面以JNDI、JDBC、Tomcat展开解释为什么要破坏双亲委派机制</p><h3 id="JNDI，JDBC破坏双亲委派"><a href="#JNDI，JDBC破坏双亲委派" class="headerlink" title="JNDI，JDBC破坏双亲委派"></a><strong>JNDI，JDBC破坏双亲委派</strong></h3><p>我们日常开发中，大多数时候会通过API的方式调用Java提供的那些基础类，这些基础类时被Bootstrap加载的。但是，调用方式除了API之外，还有一种<strong>SPI</strong>的方式。</p><p>例如典型的JDBC，需要以以下的方式创建数据库链接：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/mysql"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"1234"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>原生的JDBC中的类是放在rt.jar包的，是由<strong>启动类加载器</strong>进行类加载的（即上述的<code>DriverManager</code>类是被<code>Bootstrap ClassLoader</code>加载的），原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，JDBC中的Driver类中需要<strong>动态去加载不同数据库类型的Driver类</strong></em>，如mysql的<em>mysql-connector-</em>.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载</p><p>于是，就<strong>在JDBC中通过引入ThreadContextClassLoader（线程上下文加载器，默认情况下是AppClassLoader）的方式破坏了双亲委派原则。</strong></p><h3 id="Tomcat破坏双亲委派"><a href="#Tomcat破坏双亲委派" class="headerlink" title="Tomcat破坏双亲委派"></a><strong>Tomcat破坏双亲委派</strong></h3><p>由于Tomcat是web容器，那么一个web容器可能需要部署多个应用程序，<strong>不同的应用程序可能会依赖同一个第三方类库的不同版本</strong>，但是不同版本的类库中某一个类的<strong>全路径名可能是一样</strong>的。因而，<strong>如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。</strong></p><blockquote><p>所以，<strong>Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。</strong></p><p>所以，为了实现<strong>隔离性</strong>，每一个应用自己的类加载器——WebAppClassLoader负责加载<strong>本身的目录下的class文件</strong>，加载不到时再交给父类加载器加载，这和双亲委派刚好相反</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li>《深入理解Java虚拟机》周志明</li><li><a href="https://zhuanlan.zhihu.com/p/343563937">我竟然被“双亲委派”给虐了 - 知乎</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 双亲委派机制 </tag>
            
            <tag> ClassLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java对象的大小计算</title>
      <link href="/2021/11/08/java-dui-xiang-de-da-xiao-ji-suan/"/>
      <url>/2021/11/08/java-dui-xiang-de-da-xiao-ji-suan/</url>
      
        <content type="html"><![CDATA[<h2 id="Java对象布局"><a href="#Java对象布局" class="headerlink" title="Java对象布局"></a>Java对象布局</h2><p>一个 Java 对象在内存中存储为三部分：对象头（Header）、实例数据（Instance Data）和对齐填充 （Padding）。可以用下图来清晰表示：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/webp.webp"></p><h3 id="1、对象头"><a href="#1、对象头" class="headerlink" title="1、对象头"></a>1、对象头</h3><ul><li><p><strong>Mark Word</strong>: 用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p><pre class="line-numbers language-none"><code class="language-none">hash(25) + age(4) + lock(3) &#x3D; 32bit#32位系统unused(25+1) + hash(31) + age(4) + lock(3) &#x3D; 64bit#64位系统<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>Klass Word</strong>：类型指针，<strong>指向该对象在方法区中的 Class 类对象的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例；在 64 位系统中，开启指针压缩（-XX:+UseCompressedOops）或者 JVM 堆的最大值小于 32G，这个指针也是 4byte，否则是 8byte（就是 <strong>Java 中的一个引用的大小</strong>）</p></li><li><p>如果对象是一个<strong>数组</strong>，那在对象头中还有一块数据用于<strong>记录数组长度</strong>（多加<strong>四字节</strong>的内存：4byte/32bit）</p></li></ul><h3 id="2、实例数据"><a href="#2、实例数据" class="headerlink" title="2、实例数据"></a>2、实例数据</h3><blockquote><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的，都需要记录起来</p></blockquote><h3 id="3、对齐填充"><a href="#3、对齐填充" class="headerlink" title="3、对齐填充"></a>3、对齐填充</h3><blockquote><p>对齐填充没有特别的意义，仅仅起占位符的作用。64 位系统，由于 HotSpot VM 的自动内存管理系统要求<strong>对象起始地址必须是 8 字节的整数倍</strong>，就是对象的大小必须是 8 字节的整数倍，而对象头部分正好是 8 字节的倍数（1 倍或者 2 倍），因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补全</p></blockquote><h2 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h2><ul><li><p>基本数据类型（primitive type）</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p></li><li><p>引用类型 (reference type)</p><p>除了对象本身之外，还存在一个<strong>指向它的引用（指针）</strong>，指针占用的内存在64位虚拟机上8个字节，如果开启指针压缩是<strong>4个字节</strong>，默认是开启的。</p></li></ul><h4 id="字段重排序"><a href="#字段重排序" class="headerlink" title="字段重排序"></a>字段重排序</h4><p>为了更高效的使用内存，实例数据字段将会重排序。排序的优先级为： long = double &gt; int = float &gt; char = short &gt; byte &gt; boolean &gt; object reference</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FieldTest</span><span class="token punctuation">&#123;</span>    <span class="token keyword">byte</span> a<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> d<span class="token punctuation">;</span>    <span class="token keyword">long</span> e<span class="token punctuation">;</span>    <span class="token class-name">Object</span> f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//重排序后结果</span>OFFSET  SIZE               TYPE DESCRIPTION                <span class="token number">16</span>     <span class="token number">8</span>               <span class="token keyword">long</span> <span class="token class-name">FieldTest</span><span class="token punctuation">.</span>e                <span class="token number">24</span>     <span class="token number">4</span>                <span class="token keyword">int</span> <span class="token class-name">FieldTest</span><span class="token punctuation">.</span>c                <span class="token number">28</span>     <span class="token number">1</span>               <span class="token keyword">byte</span> <span class="token class-name">FieldTest</span><span class="token punctuation">.</span>a                <span class="token number">29</span>     <span class="token number">1</span>            <span class="token keyword">boolean</span> <span class="token class-name">FieldTest</span><span class="token punctuation">.</span>d                <span class="token number">30</span>     <span class="token number">2</span>              <span class="token punctuation">(</span>alignment<span class="token operator">/</span>padding gap<span class="token punctuation">)</span>    <span class="token number">32</span>     <span class="token number">8</span>            <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Object</span> <span class="token class-name">FieldTest</span><span class="token punctuation">.</span>f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><ul><li><p>一个int值在Java中为4byte，其包装对象Integer大小为：</p><pre class="line-numbers language-none"><code class="language-none">4(Mark Word) + 4(Klass Word) + 4(data) + 4(Padding) &#x3D; 16byte<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>​    所以可以看出，包装类型比基本数据类型占用的空间大得多！！</p><ul><li><p>类似，一个Integer数组大小为：</p><pre class="line-numbers language-none"><code class="language-none">4(Mark Word) + 4(Klass Word) + 4(length) + 4*10(10个int大小) + 4(Padding) &#x3D; 56sbyte<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="对象的实际大小"><a href="#对象的实际大小" class="headerlink" title="对象的实际大小"></a>对象的实际大小</h2><h3 id="浅堆（Shallow-Heap）"><a href="#浅堆（Shallow-Heap）" class="headerlink" title="浅堆（Shallow Heap）"></a>浅堆（Shallow Heap）</h3><p><strong>对象本身占用的内存，不包括内部引用对象的大小</strong>，32 位系统中一个对象引用占 4 个字节，每个对象头占用 8 个字节，根据堆快照格式不同，对象的大小会同 8 字节进行对齐。</p><h3 id="保留集（Retained-Set）"><a href="#保留集（Retained-Set）" class="headerlink" title="保留集（Retained Set）"></a>保留集（Retained Set）</h3><p>对象 A 的保留集指当对象 A 被垃圾回收后，<strong>可以被释放的所有的对象集合（包括 A 本身）</strong>，所以对象 A 的保留集就是只能通过对象 A 被直接或间接访问到的所有对象的集合，就是仅被对象 A 所持有的对象的集合。</p><p>对象 A 可以类比于可达性分析中的GC root元素，如果对象 A 不存在了，则此时<strong>不可达的节点</strong>都属于对象A的保留集</p><h3 id="深堆（Retained-Heap）"><a href="#深堆（Retained-Heap）" class="headerlink" title="深堆（Retained Heap）"></a>深堆（Retained Heap）</h3><p>指对象的<strong>保留集中所有的对象的浅堆大小之和</strong>，一个对象的深堆指<strong>只能</strong>通过该对象<strong>访问到的</strong>（<strong>直接或间接</strong>）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p><blockquote><p><strong>一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小</strong></p></blockquote><p>下图显示了一个简单的对象引用关系图，对象 A 引用了 C 和 D，对象 B 引用了 C 和 E。<strong>那么对象 A 的浅堆大小只是 A 本身，A 的实际大小为 A、C、D 三者之和，A 的深堆大小为 A 与 D 之和</strong>，由于对象 C 还可以通过对象 B 访问到 C，因此 C 不在对象 A 的深堆范围内</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/68747470733a2f2f67697465652e636f6d2f7365617a65616e2f696d616765732f7261772f6d61737465722f4a6176612f4a564d2de5afb9e8b1a1e79a84e5ae9ee99985e5a4a7e5b08f2e706e67.png"></p><h2 id="复杂实例"><a href="#复杂实例" class="headerlink" title="复杂实例"></a>复杂实例</h2><p>1、</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cc<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>        cc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Shallow Size</code>： 12(C Header) + 4 (i instance) + 4 (cc reference) + 4(padding) = 24bytes</p><p><code>Retained Size</code>: 12(C Header) + 4 (i instance) + 4 (cc reference) + (16(cc header,注意是数组对象头) + 2(instance) * 3+ 2(padding)) + 4(padding) = 48bytes</p><p>2、</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Fruit</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">Apple</span> brother<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">long</span> create_time<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Apple大小：12(Apple Header) + 4(Fruit.size instance) + 4(Apple.size instance) + 4(name reference) + 4(brother reference) + 8(create_time instance) + 4(padding) = 40bytes</p><p>如果假设已经初始化string = “apple”，则单独计算name内部会占用 ：</p><blockquote><p>String类型：12（header） + 4（int） + 4 （int）+ 4（char[] reference)  = 24</p><p>char[]类型：12 （header）+ 4（int，计算char[]长度的） + （2*5）（“Apple”）+ 6（padding）=32</p><p>因此，此时深堆大小为40+24+32 = 96bytes</p></blockquote><p>参考：</p><p>1、<a href="https://www.bilibili.com/video/BV1PJ411n7xZ">尚硅谷宋红康JVM全套教程（详解java虚拟机）</a></p><p>2、<a href="https://www.jianshu.com/p/6a85f0b3cdc9">Java中对象占用内存大小计算 - 简书</a></p><p>3、<a href="https://blog.csdn.net/belongtocode/article/details/103377187">(27条消息) 一个Java对象和Hashmap对象占用多大内存_Apple_Boy的博客-CSDN博客_hashmap占用内存大小</a></p><p>4、<a href="https://www.yuque.com/u21195183/jvm/nkq31c">补充：浅堆深堆与内存泄露 · 语雀</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2021/10/31/bi-bao/"/>
      <url>/2021/10/31/bi-bao/</url>
      
        <content type="html"><![CDATA[<h2 id="Function-Value"><a href="#Function-Value" class="headerlink" title="Function Value"></a>Function Value</h2><p>Go语言中函数是头等对象，可以作为参数传递，可以作为返回值，也可以绑定到变量。Go中称这样的参数，返回值或者变量为<code>function value</code>。</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/function_value.PNG"></p><p><code>function value</code>本质是上一个指针，但是并不直接指向函数的指令入口。而是指向一个<code>runtime.funcval</code>结构体，<strong>这个结构体里只有一个地址，就是这个函数指令的入口地址</strong></p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/function_value2.PNG"></p><blockquote><p>如果函数A被赋值给$f1$和$f2$两个变量，这种情况，编译器会做出优化，让$f1$和$f2$共用一个<code>funcval</code><strong>结构体</strong></p><p>假设函数A的入口地址为$addr1$（在代码段中），<strong>编译阶段</strong>，会在<strong>只读数据段</strong>分配一个<code>funcval</code>结构体，$fn$指向函数A指令入口。而它本身的起始地址$addr2$（在只读数据段中），会在执行阶段赋给$f1$和$f2$。通过$f1$来执行函数，就会通过它存储的地址找到对应<code>的funcval</code>结构体，拿到函数入口地址，然后调转执行。</p></blockquote><p>既然只要有函数入口地址就能调用 ，为什么要通过<code>funcval</code>结构体包装这个地址，然后使用一个二级指针来调用呢？这里主要是为了处理<strong>闭包</strong>的情况</p><h2 id="闭包定义"><a href="#闭包定义" class="headerlink" title="闭包定义"></a>闭包定义</h2><ul><li>必须要有在<strong>函数外部定义</strong>，但在<strong>函数内部引用</strong>的“自由变量”</li><li>脱离了形成闭包的上下文，闭包也能<strong>照常使用这些自由变量</strong></li></ul><blockquote><p>闭包函数的指令自然也是在<strong>编译阶段生成</strong>，但因为每个闭包对象都要<strong>保存自己的捕获变量</strong>。所以要到<strong>执行阶段才创建对应的闭包对象</strong></p></blockquote><p>下面用一个例子展示：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E9%97%AD%E5%8C%85.PNG"></p><p>函数<code>create</code>的返回值是一个函数，但这个函数内部使用了外部定义的变量$c$，即使<code>create</code>执行结束，通过$f1$和$f2$依然能正常调用这个闭包函数，并使用定义在<code>create</code>函数内部的局部变量$c$。</p><p>通常称这个变量$c$为<strong>捕获变量</strong>。</p><p>执行阶段，<code>main</code>函数栈帧有两个局部变量，然后是返回值空间。到<code>create</code>函数栈帧这里，有一个局部变量<code>c=2</code>。</p><p><code>create</code>函数会在堆上分配一个<code>funcval</code>结构体，$fn$指向闭包函数入口，除此之外，还有一个捕获列表，这里只捕获一个变量$c$。然后这个结构体的起始地址就<strong>作为返回值写入返回值空间</strong>，即<code>f1 = addr2</code>。接着再次调用<code>create</code>函数，它就会<strong>再次创建</strong>一个<code>funcval</code>结构体，同样捕获变量$c$，然后这个起始地址addr3作为返回值写入，即<code>f2 = addr3</code>。</p><p>通过$f1$和$f2$调用闭包函数，就会找到各自对应的<code>funcval</code>结构体，拿到同一个函数入口，但是通过$f1$调用时要使用$addr2$上面的捕获列表，$f2$调用时要使用$addr3$上面的捕获列表，这就是称闭包为<strong>有状态的函数</strong>的原因。</p><blockquote><p>函数如何找到对应的捕获列表呢？</p><p>Go语言中通过一个<code>function value</code>调用函数时，会把对应的<code>funcval</code><strong>结构体地址</strong>存入特定寄存器，例如amd64平台使用的是DX寄存器。这样在闭包函数中，就可以通过寄存器取出<code>funcval</code>结构体的地址，然后<strong>加上相应的偏移</strong>来找到每一个被捕获的变量。</p><p>所以<strong>Go语言中闭包就是有捕获列表的function value</strong>，而没有捕获列表的function value直接忽略这个寄存器的值就行</p></blockquote><h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><p>被闭包捕获的变量，要在<strong>外层函数与闭包函数中表现一致</strong>，好像它们在使用同一个变量，Go语言的编译器针对不同情况做了不同的处理</p><h3 id="1、被捕获的变量没有被修改时"><a href="#1、被捕获的变量没有被修改时" class="headerlink" title="1、被捕获的变量没有被修改时"></a>1、被捕获的变量没有被修改时</h3><p>如上面的例子，被捕获的变量除了初始化赋值外，在任何地方都没有被修改过，所以<strong>直接拷贝值</strong>到捕获列表就行</p><h3 id="2、被捕获的变量有被修改时"><a href="#2、被捕获的变量有被修改时" class="headerlink" title="2、被捕获的变量有被修改时"></a>2、被捕获的变量有被修改时</h3><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E9%97%AD%E5%8C%852.PNG"></p><p>在这个例子中，被捕获的是局部变量$i$，而且除了初始化赋值外还被修改过</p><blockquote><p>由于被闭包捕获并修改，<strong>局部变量$i$改为堆分配</strong>，在<strong>栈上只存一个地址</strong>。</p></blockquote><p>第一次for循环。在堆上创建<code>funcval</code>结构体，捕获 $i$ 的地址，这样闭包函数就和外层函数操作同一个变量了，返回值空间第一个元素存储$addr0$，第一次for循环结束，$i$自增1</p><p>第二次for循环，堆上再次分配一个<code>funcval</code>，捕获变量$i$的地址，返回值空间第二个元素存储$addr1$，第二次循环结束，$i$再次自增1，<code>create</code>函数结束，把返回值拷贝到<code>main</code>的局部变量$fs$</p><p>通过$fs[0]$调用函数时，会把$addr0$存入寄存器。闭包函数通过<strong>寄存器存储的地址加上偏移</strong>找到捕获变量$i$的地址。$fs[1]$同理，被捕获的地址都指向它，<strong>所以每次都会打印2</strong>。</p><p><strong>闭包导致的局部变量堆分配，也是变量逃逸的一种场景。</strong></p><h3 id="3、被捕获的是参数且有被修改时"><a href="#3、被捕获的是参数且有被修改时" class="headerlink" title="3、被捕获的是参数且有被修改时"></a>3、被捕获的是参数且有被修改时</h3><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E9%97%AD%E5%8C%853.PNG"></p><p>此时涉及到<strong>函数原型</strong>，就不能再像局部变量那样处理</p><p>参数依然通过调用者栈帧传入，但是<strong>编译器会把栈上这个参数拷贝到堆上一份</strong>。然后<strong>外层函数和闭包函数都使用堆上分配的这一个</strong></p><h3 id="4、被捕获的是返回值且有被修改时"><a href="#4、被捕获的是返回值且有被修改时" class="headerlink" title="4、被捕获的是返回值且有被修改时"></a>4、被捕获的是返回值且有被修改时</h3><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E9%97%AD%E5%8C%854.PNG"></p><p>调用者栈帧上依然会分配返回值的空间，不过<strong>闭包的外层函数会在堆上也分配一个</strong>，<strong>外层函数和闭包函数都使用堆上这个</strong></p><blockquote><p>与第三个例子中被捕获的是参数的情况不同的是，在外层函数返回前，<strong>需要把堆上的返回值拷贝到栈上的返回值空间</strong></p></blockquote><p>总的来说，虽然处理方式多样，但是目标只有一个，就是<strong>保存捕获变量在外层函数和闭包函数中的一致性</strong></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>幼麟实验室</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层分析 </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang的slice</title>
      <link href="/2021/10/31/golang-de-slice/"/>
      <url>/2021/10/31/golang-de-slice/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。其实 slice 也就相当于动态数组，长度并不固定，可以用append追加元素，并且slice会在容量不足时自动扩容。</p><p>在go语言中文文档中，对于slice有这样的描述：</p><blockquote><ol><li>切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。</li><li>切片的长度可以改变，因此，切片是一个可变的数组。</li><li>切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 </li><li>cap可以求出slice最大扩张容量，不能超出数组限制。0 &lt;= len(slice) &lt;= len(array)，其中array是slice引用的数组。</li><li>切片的定义：var 变量名 []类型，比如 <code>var str []string</code>     <code>var arr []int</code>。</li><li>如果 slice == nil，那么 len、cap 结果都等于 0。</li></ol></blockquote><h2 id="slice的数据结构"><a href="#slice的数据结构" class="headerlink" title="slice的数据结构"></a>slice的数据结构</h2><p>根据runtime包下的slice.go源码可以看到，slice的基本结构如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> slice <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>array unsafe<span class="token punctuation">.</span>Pointer<span class="token builtin">len</span>   <span class="token builtin">int</span><span class="token builtin">cap</span>   <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>array</code> 是指向第一个slice元素对应的底层数组元素的地址的指针;</li><li><code>len</code> 是当前切片的长度；</li><li><code>cap</code> 是当前切片的容量，即 <code>array</code> 数组的大小：</li></ul><p>注意这里len范围内的元素是可以安全访问的，超出这个范围的元素访问会<strong>导致panic</strong></p><h2 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h3><p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠，如下图所示：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/ch4-01.png"></p><blockquote><p>如果对共用的底层数组切片进行append添加元素，那么就会开辟新数组，不在共用底层数组，原来的元素拷贝过去，并且在新数组上添加新元素。</p></blockquote><h3 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h3><p>和数组不同的是，slice之间不能比较，因此我们<strong>不能使用==操作符来判断两个slice是否含有全部相等元素</strong>。不过标准库提供了高度优化的<code>bytes.Equal</code>函数来判断两个字节型slice是否相等（限于**[]byte**），但是对于其他类型的slice，我们必须自己展开每个元素进行比较</p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">func equal(x, y []string) bool &#123;    if len(x) !&#x3D; len(y) &#123;        return false    &#125;    for i :&#x3D; range x &#123;        if x[i] !&#x3D; y[i] &#123;            return false        &#125;    &#125;    return true&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果==使用的是<strong>浅度相等</strong>，只要两个slice的指针，长度和容量三个字段相等，那么两个slice就相等。但这样和数组不同的相等测试方法，会让人困惑，如：</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 两个数组相等</span>    a1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    a2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a1 <span class="token operator">==</span> a2<span class="token punctuation">)</span>    <span class="token comment">// true</span>    <span class="token comment">// 如果slice使用的是浅相等</span>    a1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    a2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a1 <span class="token operator">==</span> a2<span class="token punctuation">)</span>   <span class="token comment">// false，和数组的行为不同，造成困惑</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果==使用的是<strong>深度相等</strong>，和数组的行为保持一致，那也会有下面的问题。正常情况下，将一个slice赋值给另一个slice时，我们只是复制slice的结构体，<strong>两个slice的指针都指向同一个底层数组</strong>。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    s1 <span class="token operator">:=</span> s0    s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>   <span class="token comment">// 通过s1修改，会影响到s0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>slice唯一合法的比较操作是和nil比较</strong></p><h2 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h2><p>在slice.go下，有一个扩容growslice函数，当切片的容量不足时，便会调用该函数进行切片扩容，关键源码如下所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> slice <span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token operator">...</span>    newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>    doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap    <span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">></span> doublecap <span class="token punctuation">&#123;</span>       newcap <span class="token operator">=</span> <span class="token builtin">cap</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span> <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">&#123;</span>          newcap <span class="token operator">=</span> doublecap       <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// Check 0 &lt; newcap to detect overflow</span>          <span class="token comment">// and prevent an infinite loop.</span>          <span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">&#123;</span>             newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span>          <span class="token punctuation">&#125;</span>          <span class="token comment">// Set newcap to the requested cap when</span>          <span class="token comment">// the newcap calculation overflowed.</span>          <span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>             newcap <span class="token operator">=</span> <span class="token builtin">cap</span>          <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，扩容的具体规则为：</p><ol><li>如果期望容量<strong>大于当前容量的两倍</strong>就会使用期望容量；</li><li>如果当前切片的长度<strong>小于 1024</strong> 就会将容量<strong>翻倍</strong>；</li><li>如果当前切片的长度<strong>大于 1024</strong> 就会<strong>每次增加 25% 的容量</strong>，直到新容量大于期望容量；</li></ol><p>上述过程仅是进行了新容量的预估，接下来还需要根据切片中的元素大小<strong>对齐内存</strong>。</p><blockquote><p>比如新容量是3，<code>int</code>类型，则它需要申请<code>24B</code>的内存，此时它会向语言自身的<strong>内存管理模块</strong>去申请内存</p><p>而内存管理模块会提前向操作系统申请一批内存，分为常用的规格管理起来，我们申请内存时，它会帮我们<strong>匹配到足够大，且最接近规格的内存</strong>，可能这里内存管理模块分配给你了<code>32B</code>的内存，所以这个时候新容量变成4个了</p><p><img src="E:/%E6%A0%A1%E6%8B%9B%E5%87%86%E5%A4%87/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/blog/source/_posts/imgs/image-20220105003609592-16544417681623.png"></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//runtime下sizeclasses.go文件，基本的内存单元如下</span><span class="token keyword">var</span> class_to_size <span class="token operator">=</span> <span class="token punctuation">[</span>_NumSizeClasses<span class="token punctuation">]</span><span class="token builtin">uint16</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">,</span> <span class="token number">112</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">144</span><span class="token punctuation">,</span> <span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">176</span><span class="token punctuation">,</span> <span class="token number">192</span><span class="token punctuation">,</span> <span class="token number">208</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">240</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">288</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">352</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">416</span><span class="token punctuation">,</span> <span class="token number">448</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">576</span><span class="token punctuation">,</span> <span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">704</span><span class="token punctuation">,</span> <span class="token number">768</span><span class="token punctuation">,</span> <span class="token number">896</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">1152</span><span class="token punctuation">,</span> <span class="token number">1280</span><span class="token punctuation">,</span> <span class="token number">1408</span><span class="token punctuation">,</span> <span class="token number">1536</span><span class="token punctuation">,</span> <span class="token number">1792</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">,</span> <span class="token number">2304</span><span class="token punctuation">,</span> <span class="token number">2688</span><span class="token punctuation">,</span> <span class="token number">3072</span><span class="token punctuation">,</span> <span class="token number">3200</span><span class="token punctuation">,</span> <span class="token number">3456</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">4864</span><span class="token punctuation">,</span> <span class="token number">5376</span><span class="token punctuation">,</span> <span class="token number">6144</span><span class="token punctuation">,</span> <span class="token number">6528</span><span class="token punctuation">,</span> <span class="token number">6784</span><span class="token punctuation">,</span> <span class="token number">6912</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">,</span> <span class="token number">9472</span><span class="token punctuation">,</span> <span class="token number">9728</span><span class="token punctuation">,</span> <span class="token number">10240</span><span class="token punctuation">,</span> <span class="token number">10880</span><span class="token punctuation">,</span> <span class="token number">12288</span><span class="token punctuation">,</span> <span class="token number">13568</span><span class="token punctuation">,</span> <span class="token number">14336</span><span class="token punctuation">,</span> <span class="token number">16384</span><span class="token punctuation">,</span> <span class="token number">18432</span><span class="token punctuation">,</span> <span class="token number">19072</span><span class="token punctuation">,</span> <span class="token number">20480</span><span class="token punctuation">,</span> <span class="token number">21760</span><span class="token punctuation">,</span> <span class="token number">24576</span><span class="token punctuation">,</span> <span class="token number">27264</span><span class="token punctuation">,</span> <span class="token number">28672</span><span class="token punctuation">,</span> <span class="token number">32768</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li>《Go语言设计与实现》</li><li>《Go语言圣经》</li><li> 幼麟实验室的Golang合辑</li><li>Go语言中文文档</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层分析 </tag>
            
            <tag> slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数调用栈的传参与返回值</title>
      <link href="/2021/10/30/han-shu-diao-yong-zhan-de-chuan-can-yu-fan-hui-zhi/"/>
      <url>/2021/10/30/han-shu-diao-yong-zhan-de-chuan-can-yu-fan-hui-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>我们知道，由于Go语言是值传递，如果在被调用函数内部交换两个数的值，调用者内部对应的实参是不会发生变化的，就如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/swap%E5%87%BD%E6%95%B0.PNG"></p><p>但这个现象的原因从函数调用栈来说具体的机理是什么呢？我们通过函数调用栈看看问题到底出在哪</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/swap%E6%A0%88%E5%B8%A7.PNG"></p><p>由于函数调用没有返回值，所以局部变量后面就是给被调用函数传入的参数$args$，注意调用函数的<strong>参数入栈顺序由右到左，返回值也是一样</strong>（原因是这样被调用函数通过**$sp$+偏移寻址**就比较方便了）</p><p>可以看出，当<code>swap</code>函数交换两数时，交换的是<code>args</code>内的$a、b$，而不是<code>main</code>函数中的局部变量，所以<code>main</code>函数中的$a、b$交换失败。</p><h2 id="传指针的例子"><a href="#传指针的例子" class="headerlink" title="传指针的例子"></a>传指针的例子</h2><p>同理与上面的例子，我们便可以很容易理解传指针时为什么可以成功交换$a、b$的值</p><p><img src="https://testingcf.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/swap%E5%87%BD%E6%95%B02.PNG"></p><p>此时的栈帧空间分布如下：</p><p><img src="https://testingcf.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/swap%E6%A0%88%E5%B8%A72.PNG"></p><p><code>swap</code>执行到<code>*a,*b=*b,*a</code>时，交换的是这两个指针指向的数据，也就是这两个地址的数据，所以这一次能交换成功</p><h2 id="匿名函数返回值"><a href="#匿名函数返回值" class="headerlink" title="匿名函数返回值"></a>匿名函数返回值</h2><p>Go语言支持多返回值，所以在<strong>栈上分配返回值空间</strong>更合适</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%8C%BF%E5%90%8D%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0.PNG"></p><p>首先，栈帧上所有的$a、b$初始均等于0，执行到①处时，被调用函数的参数<code>args</code>上的$a$自增为1，接着执行到②，<code>incr</code>函数栈帧的$b$被赋值等于1。</p><blockquote><p>注：<strong>defer与return时机</strong></p><p>return赋值和返回是两个步骤，不是原子操作，如果有defer会插在两个步骤中:</p><ol><li>返回值赋值(return value)</li><li>defer语句 </li><li>返回值真正返回，调用函数结束</li></ol></blockquote><p>所以<code>return</code>函数先将<code>incr</code>函数栈帧的$b$赋值给返回值，也就是此时的栈空间是这样的</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%8C%BF%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7.PNG"></p><p>接着执行<code>defer</code>函数，<code>args</code>上的$a$再自增1，<code>incr</code>函数局部变量$b$也自增1，然后<code>incr</code>结束。此时返回值为1，所以<code>main</code>函数中的$b$最终被赋值为1，而<code>main</code>函数中的$a$并不会收到<code>incr</code>函数的影响，值仍然为0。最终的栈内布局是这样的：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%8C%BF%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A72.PNG"></p><p><strong>所以最终输出的是0和1</strong></p><h2 id="具名返回值函数"><a href="#具名返回值函数" class="headerlink" title="具名返回值函数"></a>具名返回值函数</h2><p>假如我们其他都不变，只把这里的局部变量b，改成命名返回值，看看有什么不同</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/6a677dc56a02460b895f40b4063dcdbe.png"></p><p>当执行到<code>a++</code>时，参数$a$自增1，由于是具名返回值函数，此时返回值$b$被赋予为1</p><p>接着<code>defer</code>函数，参数$a$再自增1，返回值b也自增1，<code>incr</code>结束，所以最终返回值$b$的值为2</p><h2 id="调用多个函数时的小问题"><a href="#调用多个函数时的小问题" class="headerlink" title="调用多个函数时的小问题"></a>调用多个函数时的小问题</h2><p>如果一个函数A调用了两个函数B和C。但是这<strong>两个函数的参数和返回值占用的空间并不相同</strong>，而Go语言的函数栈帧是一次性分配的，所以要以<strong>最大的参数加返回值空间为标准来分配栈帧空间</strong>，才能满足所有被调函数的需求</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0.PNG"></p><p>假设B的参数和返回值占用的空间大，当调用B时，B的参数和返回值可以把分配的参数加返回值空间占满没有问题，但是调用B时，B的参数和返回值<strong>只会占用靠近栈顶的那部分空间</strong>（即上图方框中靠下的部分）</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B02.PNG"></p><blockquote><p>原因是虽然上面空出来一块，但是被调用者<strong>通过栈指针相对寻址</strong>自己的参数和返回值时会比较方便</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>幼麟实验室的Golang合辑</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层分析 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数调用栈分析</title>
      <link href="/2021/10/30/han-shu-diao-yong-zhan-fen-xi/"/>
      <url>/2021/10/30/han-shu-diao-yong-zhan-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="函数基本结构"><a href="#函数基本结构" class="headerlink" title="函数基本结构"></a>函数基本结构</h2><p>G语言中函数的声明的基本形式如下：</p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">func name(parameter-list) (result-list) &#123;    body&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中<strong>函数的类型被称为函数的签名</strong>。如果两个函数<strong>形式参数列表</strong>和<strong>返回值列表</strong>中的<strong>变量类型</strong>一一对应，那么这两个函数被认为有相同的类型或签名。</p><p>形参和返回值的<strong>变量名</strong>不影响函数签名，也不影响它们是否可以以省略参数类型的形式表示。</p><p>Go语言的实参通过<strong>值的方式传递</strong>，因此函数的形参是实参的拷贝，只有传递指针、slice(切片)、map、function、channel等类型才可能导致实参的修改。</p><h2 id="函数栈帧布局"><a href="#函数栈帧布局" class="headerlink" title="函数栈帧布局"></a>函数栈帧布局</h2><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7.png" alt="函数栈帧"></p><p>我们用Go语言写的函数，会被编译器编译为一堆机器指令，写入可执行文件，程序执行时，可执行文件被加载到内存，这些机器指令对应到虚拟地址空间中，位于代码段</p><p>如果在一个函数中调用另一个函数，编译器就会对应生成一条<code>call</code>指令，程序执行到这条指令时，就会跳转到被调用函数处开始执行，而每个函数的最后都有一条<code>ret</code>指令，负责在函数结束后跳回到调用处，继续执行。</p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A72.png" /><p>由图中可以看出，一个栈帧的从栈底到栈顶的布局是：</p><blockquote><p> <strong>调用者栈基  =&gt; 局部变量 =&gt; 被调用函数返回值 =&gt; 被调用函数参数</strong></p></blockquote><p>而之前说的<code>call</code>指令，就只做两件事：</p><blockquote><ol><li>将下一条指定的地址入栈，这就是<strong>返回地址</strong>，被调用函数执行结束后会跳回到这里。</li><li>跳转到<strong>被调用函数的入口处</strong>开始执行</li></ol></blockquote><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A73.png"></p><p>所有的函数的栈帧布局都遵循统一的约定，故被调用者是通<strong>过栈指针加上相应的偏移</strong>来定位到每个参数和返回值的</p><blockquote><p>注意，返回地址是被CALL指令压栈的，故其<strong>既不属于调用者栈帧，也不属于被调用者栈帧的内容</strong>。</p></blockquote><h2 id="栈帧的内存分配"><a href="#栈帧的内存分配" class="headerlink" title="栈帧的内存分配"></a>栈帧的内存分配</h2><p>Go语言的栈不是逐步扩张的，而是<strong>一次性分配</strong>，也就是在<strong>分配栈帧时，直接将栈指针移动到所需最大栈空间的位置</strong>，然后通过<strong>栈指针+偏移值这种相对寻址方式</strong>使用函数栈帧。</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.PNG"></p><p>之所以这样分配，就是为了防止出现上图中所示的访问越界的情况。</p><p>函数栈帧的大小，可以在编译时期确定，对于栈消耗较大的函数，Go语言的编译器会在<strong>函数头部插入检测代码</strong>，如果发现需要进行“栈增长”，就会另外分配一段足够大的栈空间，并把原来栈上的数据拷贝过来，并且将原来这段栈空间释放。</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%802.PNG"></p><h2 id="函数跳转与返回的实现"><a href="#函数跳转与返回的实现" class="headerlink" title="函数跳转与返回的实现"></a>函数跳转与返回的实现</h2><p>假设一个函数$A$在$a1$处调用函数$B$，起初栈内存布局以及寄存器情况如下：</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%87%BD%E6%95%B0%E8%B7%B3%E8%BD%AC%E4%B8%8E%E8%BF%94%E5%9B%9E.PNG"></p><p>代码执行到$a1$，调用<code>call</code>指令，便会执行两步：</p><ol><li><strong>把下一条指令执行地址$a2$入栈保存起来，即保存到$s3$处</strong></li><li><strong>跳转到指令执行地址$b1$处</strong></li></ol><p>接着函数$B$代码开始执行，先把 $sp$ 向下移动24字节（这里是说明性演示，假设分配的栈帧大小即为24字节），为自己分配足够大的栈帧；接着执行$b2$这条指令，把<strong>调用者栈基</strong><code>(caller’s bp -&gt; s1)</code>存到$sp+16$的地方，接下来$b3$指令把$sp+16$的地址存入栈基寄存器$bp$，接下来就可以执行函数$B$剩下的指令了。</p><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%87%BD%E6%95%B0%E8%B7%B3%E8%BD%AC%E4%B8%8E%E8%BF%94%E5%9B%9E2.PNG"></p><p>执行完$B$剩余的指令后，在<code>ret</code>指令之前，编译器还会插入两条指令：</p><blockquote><ol><li>恢复调用者$A$的栈基地址，它之前被存储在$sp+16$字节这里，这就是为什么栈帧布局第一条就是<code>caller’s bp</code>的原因，</li><li>释放自己的栈帧空间，分配时向下移动多少，释放时就向上移动多少</li></ol></blockquote><p><img src="https://fastly.jsdelivr.net/gh/Li-Zhenhua/blogpicture@main/img/%E5%87%BD%E6%95%B0%E8%B7%B3%E8%BD%AC%E4%B8%8E%E8%BF%94%E5%9B%9E3.PNG"></p><p>接着就是<code>ret</code>指令了，其首先是弹出<code>call</code>指令压栈的<strong>返回地址</strong>，这里即为$sp$指向的$a2$；第二，指令指针寄存器跳转到这个返回地址，然后代码就可以重新从$a2$执行了</p><blockquote><p>总的来说，函数通过<code>call</code>指令实现跳转，而每个函数开始时会分配栈帧，结束前又会释放自己的栈帧，<code>ret</code>指令又会把<code>call</code>恢复到<code>call</code>之前的样子，通过这些指令的配合能够实现函数的层层嵌套。</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li>幼麟实验室的Golang合辑</li><li>《Go语言圣经》</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层分析 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
