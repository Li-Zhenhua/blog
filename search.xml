<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>双亲委派机制</title>
      <link href="/blog-article/2022/01/09/shuang-qin-wei-pai-ji-zhi/"/>
      <url>/blog-article/2022/01/09/shuang-qin-wei-pai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>从Java虚拟机的角度上讲，其实只存在两种不同的类加载器，一是启动类加载器（<code>Bootstrap ClassLoader</code>），其为虚拟机的一部分，二是其他所有的类加载器。</p><p>但是从开发人员的角度上说，类加载器可以分得更为细致。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/image-20220109200810277.png"></p><p>一般认为上一层加载器是下一层加载器的父加载器，因而，除了<code>BootstrapClassLoader</code>之外，所有的加载器都是有父加载器的。</p><h3 id="启动类加载器（引导类加载器，Bootstrap-ClassLoader）"><a href="#启动类加载器（引导类加载器，Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（引导类加载器，Bootstrap ClassLoader）"></a><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></h3><ul><li><p>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</p></li><li><p>它用来加载<strong>Java的核心库</strong>（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</p></li><li><p>并不继承自ava.lang.ClassLoader，没有父加载器。</p></li><li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p></li><li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为<strong>java、javax、sun</strong>等开头的类</p></li></ul><h3 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a><strong>扩展类加载器（Extension ClassLoader）</strong></h3><ul><li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p></li><li><p>派生于ClassLoader类</p></li><li><p>父类加载器为启动类加载器</p></li><li><p>从<strong>java.ext.dirs</strong>系统属性所指定的目录中加载类库，或从JDK的安装目录的<strong>jre/1ib/ext</strong>子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p></li></ul><h3 id="应用程序类加载器（系统类加载器，AppClassLoader）"><a href="#应用程序类加载器（系统类加载器，AppClassLoader）" class="headerlink" title="应用程序类加载器（系统类加载器，AppClassLoader）"></a><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></h3><ul><li><p>java语言编写，由sun.misc.LaunchersAppClassLoader实现</p></li><li><p>派生于ClassLoader类</p></li><li><p>父类加载器为扩展类加载器</p></li><li><p>它负责加载<strong>环境变量classpath或系统属性java.class.path指定路径下的类库</strong></p></li><li><p>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</p></li><li><p>通过ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</p></li></ul><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>主要用途：隔离加载类、修改类加载的方式、扩展加载源、防止源码泄漏</p><blockquote><p>补充：<strong>获取ClassLoader的途径</strong></p><ol><li><p>获取当前ClassLoader  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">clazz<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取当前线程上下文的ClassLoader  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取系统的ClassLoader  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取调用者的ClassLoader  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getCallerClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol></blockquote><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><blockquote><p>定义：</p><p><strong>当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。</strong></p></blockquote><p><strong>好处</strong>：</p><p>1、因为类加载器之间有严格的层次关系，那么<strong>Java的类也随之具备了一种带优先级的层次关系</strong>。</p><p>2、<strong>通过双亲委派的方式，还保证了安全性</strong>（因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Object，那么这个类是不会被随意替换的，可以避免有人自定义一个有破坏功能的java.lang.Object被加载，也就是<strong>沙箱安全机制</strong>）</p><blockquote><p><strong>“父子加载器”之间的关系是继承吗？</strong></p><p>不是！！</p><p>类加载器之间的父子关系一般<strong>不会以继承（Inheritance）的关系</strong>来实现，而是都使用<strong>组合（Composition）关系</strong>来复用父加载器的代码的</p></blockquote><h2 id="双亲委派是怎么实现的？"><a href="#双亲委派是怎么实现的？" class="headerlink" title="双亲委派是怎么实现的？"></a><strong>双亲委派是怎么实现的？</strong></h2><p>在java.lang.ClassLoader的loadClass()方法的短短数十行之中有很清晰地描述</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// First, check if the class has already been loaded</span>                <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                            c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// ClassNotFoundException thrown if class not found</span>                        <span class="token comment">// from the non-null parent class loader</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token comment">// If still not found, then invoke findClass in order</span>                        <span class="token comment">// to find the class.</span>                        c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">return</span> c<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体过程从代码不难看出：</p><p>1、先检查类是否已经被加载过</p><p>2、若没有加载则调用父加载器的<code>loadClass()</code>方法进行加载</p><p>3、若父加载器为空则默认使用启动类加载器作为父加载器。</p><p>4、如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的<code>findClass()</code>方法进行加载。</p><h2 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h2><p>从上面可以看到，因为他的双亲委派过程都是在<code>loadClass()</code>方法中实现的，那么<strong>想要破坏这种机制，那么就自定义一个类加载器，重写其中的<code>loadClass()</code>方法，使其不进行双亲委派即可</strong></p><blockquote><p><strong>双亲委派被破坏的例子</strong>：</p><p><strong>1、双亲委派出现之前。</strong></p><p>由于双亲委派模型是在JDK1.2之后才被引入的，而在这之前已经有用户自定义类加载器在用了。所以，这些是没有遵守双亲委派原则的。</p><p><strong>2、JNDI、JDBC等需要加载SPI接口实现类的情况。</strong></p><p>这种情况是基础类型想要调用回用户的代码（而根据双亲委派机制，越基础的类由越上层的加载器进行加载） =&gt; 引入线程上下文类加载器（Thread Context ClassLoader）</p><p><strong>3、为了实现热插拔热部署工具。</strong></p><p>为了让代码动态生效而无需重启，实现方式时把模块连同类加载器一起换掉就实现了代码的热替换。</p><p><strong>4、Tomcat等web容器的出现。</strong></p><p><strong>5、OSGI、Jigsaw等模块化技术的应用。</strong></p></blockquote><p>下面以JNDI、JDBC、Tomcat展开解释为什么要破坏双亲委派机制</p><h3 id="JNDI，JDBC破坏双亲委派"><a href="#JNDI，JDBC破坏双亲委派" class="headerlink" title="JNDI，JDBC破坏双亲委派"></a><strong>JNDI，JDBC破坏双亲委派</strong></h3><p>我们日常开发中，大多数时候会通过API的方式调用Java提供的那些基础类，这些基础类时被Bootstrap加载的。但是，调用方式除了API之外，还有一种<strong>SPI</strong>的方式。</p><p>例如典型的JDBC，需要以以下的方式创建数据库链接：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/mysql"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"1234"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>原生的JDBC中的类是放在rt.jar包的，是由<strong>启动类加载器</strong>进行类加载的（即上述的<code>DriverManager</code>类是被<code>Bootstrap ClassLoader</code>加载的），原生的JDBC中Driver驱动本身只是一个接口，并没有具体的实现，JDBC中的Driver类中需要<strong>动态去加载不同数据库类型的Driver类</strong></em>，如mysql的<em>mysql-connector-</em>.jar中的Driver类是用户自己写的代码，那启动类加载器肯定是不能进行加载的，既然是自己编写的代码，那就需要由应用程序启动类去进行类加载</p><p>于是，就<strong>在JDBC中通过引入ThreadContextClassLoader（线程上下文加载器，默认情况下是AppClassLoader）的方式破坏了双亲委派原则。</strong></p><h3 id="Tomcat破坏双亲委派"><a href="#Tomcat破坏双亲委派" class="headerlink" title="Tomcat破坏双亲委派"></a><strong>Tomcat破坏双亲委派</strong></h3><p>由于Tomcat是web容器，那么一个web容器可能需要部署多个应用程序，<strong>不同的应用程序可能会依赖同一个第三方类库的不同版本</strong>，但是不同版本的类库中某一个类的<strong>全路径名可能是一样</strong>的。因而，<strong>如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。</strong></p><blockquote><p>所以，<strong>Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。</strong></p><p>所以，为了实现<strong>隔离性</strong>，每一个应用自己的类加载器——WebAppClassLoader负责加载<strong>本身的目录下的class文件</strong>，加载不到时再交给父类加载器加载，这和双亲委派刚好相反</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li>《深入理解Java虚拟机》周志明</li><li><a href="https://zhuanlan.zhihu.com/p/343563937">我竟然被“双亲委派”给虐了 - 知乎</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双亲委派机制 </tag>
            
            <tag> JVM </tag>
            
            <tag> ClassLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原地哈希</title>
      <link href="/blog-article/2021/12/26/yuan-di-ha-xi/"/>
      <url>/blog-article/2021/12/26/yuan-di-ha-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>假设有一个长度$n$的数组，所有数字都在 $0～ n-1$ 的范围内。数组中某些数字可能是重复的，这时要我们找出数组中其中一个重复的数字，且时间复杂度 $O(n)$，空间复杂度为常数，此时应该怎么实现呢？</p></blockquote><hr><p>一般而言，对于这样的问题，通常想法是<strong>排序</strong>或者用一个<strong>Map</strong>进行存储，但是这样都会违背时间或空间复杂度的要求，所以出现了<strong>”原地哈希“</strong>的思想</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>容易知道，对于长度$n$的数组，所有数字都在 $0～ n-1$ 的范围内时，如果没有重复元素，那么数组的索引和值将会是<strong>一对一</strong>的关系。也就是说，<strong>重复</strong>的元素导致了<strong>一对多</strong>的映射关系。</p><p>因此，可以遍历数组，将索引和值进行尽可能多的一一对应映射，即使得 $nums[i] = i$。这样，相当于在<strong>原数组</strong>上进行了一个Map映射，也就是原地哈希名称的由来。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%8E%9F%E5%9C%B0hash.png"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h2><p>由上面的算法思路，我们可以知道，如果数组索引和值的映射关系并非一一对应时，运用上述算法我们便可以推广到找数组中重复或缺失的元素</p><blockquote><p>假设一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p></blockquote><p>上述题目中对于每一个索引 $i$，经过元素换位后，索引$i$对应的正整数值 $i+1$ 若出现在数组中，一定已经换位到索引$i$处，其余的索引值要么为非正数，要么大于数组长度$n$。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C2.png"></p><p>总之，找到第一个 $nums[j]!= j$ 位置处即为所要找的数组中最小的未出现过的正整数对应的索引，对应的数值为$j+1$</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> n <span class="token operator">||</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>i<span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//此时也就是这n个数正好是1~n，所以最小未出现的正整数即为n+1</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原地hash </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/blog-article/2021/10/31/bi-bao/"/>
      <url>/blog-article/2021/10/31/bi-bao/</url>
      
        <content type="html"><![CDATA[<h2 id="Function-Value"><a href="#Function-Value" class="headerlink" title="Function Value"></a>Function Value</h2><p>Go语言中函数是头等对象，可以作为参数传递，可以作为返回值，也可以绑定到变量。Go中称这样的参数，返回值或者变量为<code>function value</code>。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/function_value.PNG"></p><p><code>function value</code>本质是上一个指针，但是并不直接指向函数的指令入口。而是指向一个<code>runtime.funcval</code>结构体，<strong>这个结构体里只有一个地址，就是这个函数指令的入口地址</strong></p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/function_value2.PNG"></p><blockquote><p>如果函数A被赋值给$f1$和$f2$两个变量，这种情况，编译器会做出优化，让$f1$和$f2$共用一个<code>funcval</code><strong>结构体</strong></p><p>假设函数A的入口地址为$addr1$（在代码段中），<strong>编译阶段</strong>，会在<strong>只读数据段</strong>分配一个<code>funcval</code>结构体，$fn$指向函数A指令入口。而它本身的起始地址$addr2$（在只读数据段中），会在执行阶段赋给$f1$和$f2$。通过$f1$来执行函数，就会通过它存储的地址找到对应<code>的funcval</code>结构体，拿到函数入口地址，然后调转执行。</p></blockquote><p>既然只要有函数入口地址就能调用 ，为什么要通过<code>funcval</code>结构体包装这个地址，然后使用一个二级指针来调用呢？这里主要是为了处理<strong>闭包</strong>的情况</p><h2 id="闭包定义"><a href="#闭包定义" class="headerlink" title="闭包定义"></a>闭包定义</h2><ul><li>必须要有在<strong>函数外部定义</strong>，但在<strong>函数内部引用</strong>的“自由变量”</li><li>脱离了形成闭包的上下文，闭包也能<strong>照常使用这些自由变量</strong></li></ul><blockquote><p>闭包函数的指令自然也是在<strong>编译阶段生成</strong>，但因为每个闭包对象都要<strong>保存自己的捕获变量</strong>。所以要到<strong>执行阶段才创建对应的闭包对象</strong></p></blockquote><p>下面用一个例子展示：</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E9%97%AD%E5%8C%85.PNG"></p><p>函数<code>create</code>的返回值是一个函数，但这个函数内部使用了外部定义的变量$c$，即使<code>create</code>执行结束，通过$f1$和$f2$依然能正常调用这个闭包函数，并使用定义在<code>create</code>函数内部的局部变量$c$。</p><p>通常称这个变量$c$为<strong>捕获变量</strong>。</p><p>执行阶段，<code>main</code>函数栈帧有两个局部变量，然后是返回值空间。到<code>create</code>函数栈帧这里，有一个局部变量<code>c=2</code>。</p><p><code>create</code>函数会在堆上分配一个<code>funcval</code>结构体，$fn$指向闭包函数入口，除此之外，还有一个捕获列表，这里只捕获一个变量$c$。然后这个结构体的起始地址就<strong>作为返回值写入返回值空间</strong>，即<code>f1 = addr2</code>。接着再次调用<code>create</code>函数，它就会<strong>再次创建</strong>一个<code>funcval</code>结构体，同样捕获变量$c$，然后这个起始地址addr3作为返回值写入，即<code>f2 = addr3</code>。</p><p>通过$f1$和$f2$调用闭包函数，就会找到各自对应的<code>funcval</code>结构体，拿到同一个函数入口，但是通过$f1$调用时要使用$addr2$上面的捕获列表，$f2$调用时要使用$addr3$上面的捕获列表，这就是称闭包为<strong>有状态的函数</strong>的原因。</p><blockquote><p>函数如何找到对应的捕获列表呢？</p><p>Go语言中通过一个<code>function value</code>调用函数时，会把对应的<code>funcval</code><strong>结构体地址</strong>存入特定寄存器，例如amd64平台使用的是DX寄存器。这样在闭包函数中，就可以通过寄存器取出<code>funcval</code>结构体的地址，然后<strong>加上相应的偏移</strong>来找到每一个被捕获的变量。</p><p>所以<strong>Go语言中闭包就是有捕获列表的function value</strong>，而没有捕获列表的function value直接忽略这个寄存器的值就行</p></blockquote><h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><p>被闭包捕获的变量，要在<strong>外层函数与闭包函数中表现一致</strong>，好像它们在使用同一个变量，Go语言的编译器针对不同情况做了不同的处理</p><h3 id="1、被捕获的变量没有被修改时"><a href="#1、被捕获的变量没有被修改时" class="headerlink" title="1、被捕获的变量没有被修改时"></a>1、被捕获的变量没有被修改时</h3><p>如上面的例子，被捕获的变量除了初始化赋值外，在任何地方都没有被修改过，所以<strong>直接拷贝值</strong>到捕获列表就行</p><h3 id="2、被捕获的变量有被修改时"><a href="#2、被捕获的变量有被修改时" class="headerlink" title="2、被捕获的变量有被修改时"></a>2、被捕获的变量有被修改时</h3><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E9%97%AD%E5%8C%852.PNG"></p><p>在这个例子中，被捕获的是局部变量$i$，而且除了初始化赋值外还被修改过</p><blockquote><p>由于被闭包捕获并修改，<strong>局部变量$i$改为堆分配</strong>，在<strong>栈上只存一个地址</strong>。</p></blockquote><p>第一次for循环。在堆上创建<code>funcval</code>结构体，捕获 $i$ 的地址，这样闭包函数就和外层函数操作同一个变量了，返回值空间第一个元素存储$addr0$，第一次for循环结束，$i$自增1</p><p>第二次for循环，堆上再次分配一个<code>funcval</code>，捕获变量$i$的地址，返回值空间第二个元素存储$addr1$，第二次循环结束，$i$再次自增1，<code>create</code>函数结束，把返回值拷贝到<code>main</code>的局部变量$fs$</p><p>通过$fs[0]$调用函数时，会把$addr0$存入寄存器。闭包函数通过<strong>寄存器存储的地址加上偏移</strong>找到捕获变量$i$的地址。$fs[1]$同理，被捕获的地址都指向它，<strong>所以每次都会打印2</strong>。</p><p><strong>闭包导致的局部变量堆分配，也是变量逃逸的一种场景。</strong></p><h3 id="3、被捕获的是参数且有被修改时"><a href="#3、被捕获的是参数且有被修改时" class="headerlink" title="3、被捕获的是参数且有被修改时"></a>3、被捕获的是参数且有被修改时</h3><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E9%97%AD%E5%8C%853.PNG"></p><p>此时涉及到<strong>函数原型</strong>，就不能再像局部变量那样处理</p><p>参数依然通过调用者栈帧传入，但是<strong>编译器会把栈上这个参数拷贝到堆上一份</strong>。然后<strong>外层函数和闭包函数都使用堆上分配的这一个</strong></p><h3 id="4、被捕获的是返回值且有被修改时"><a href="#4、被捕获的是返回值且有被修改时" class="headerlink" title="4、被捕获的是返回值且有被修改时"></a>4、被捕获的是返回值且有被修改时</h3><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E9%97%AD%E5%8C%854.PNG"></p><p>调用者栈帧上依然会分配返回值的空间，不过<strong>闭包的外层函数会在堆上也分配一个</strong>，<strong>外层函数和闭包函数都使用堆上这个</strong></p><blockquote><p>与第三个例子中被捕获的是参数的情况不同的是，在外层函数返回前，<strong>需要把堆上的返回值拷贝到栈上的返回值空间</strong></p></blockquote><p>总的来说，虽然处理方式多样，但是目标只有一个，就是<strong>保存捕获变量在外层函数和闭包函数中的一致性</strong></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>幼麟实验室</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层分析 </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang的slice</title>
      <link href="/blog-article/2021/10/31/golang-de-slice/"/>
      <url>/blog-article/2021/10/31/golang-de-slice/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。其实 slice 也就相当于动态数组，长度并不固定，可以用append追加元素，并且slice会在容量不足时自动扩容。</p><p>在go语言中文文档中，对于slice有这样的描述：</p><blockquote><ol><li>切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。</li><li>切片的长度可以改变，因此，切片是一个可变的数组。</li><li>切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 </li><li>cap可以求出slice最大扩张容量，不能超出数组限制。0 &lt;= len(slice) &lt;= len(array)，其中array是slice引用的数组。</li><li>切片的定义：var 变量名 []类型，比如 <code>var str []string</code>     <code>var arr []int</code>。</li><li>如果 slice == nil，那么 len、cap 结果都等于 0。</li></ol></blockquote><h2 id="slice的数据结构"><a href="#slice的数据结构" class="headerlink" title="slice的数据结构"></a>slice的数据结构</h2><p>根据runtime包下的slice.go源码可以看到，slice的基本结构如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> slice <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>array unsafe<span class="token punctuation">.</span>Pointer<span class="token builtin">len</span>   <span class="token builtin">int</span><span class="token builtin">cap</span>   <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>array</code> 是指向第一个slice元素对应的底层数组元素的地址的指针;</li><li><code>len</code> 是当前切片的长度；</li><li><code>cap</code> 是当前切片的容量，即 <code>array</code> 数组的大小：</li></ul><p>注意这里len范围内的元素是可以安全访问的，超出这个范围的元素访问会<strong>导致panic</strong></p><h2 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h3><p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠，如下图所示：</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/ch4-01.png" alt="img"></p><blockquote><p>如果对共用的底层数组切片进行append添加元素，那么就会开辟新数组，不在共用底层数组，原来的元素拷贝过去，并且在新数组上添加新元素。</p></blockquote><h3 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h3><p>和数组不同的是，slice之间不能比较，因此我们<strong>不能使用==操作符来判断两个slice是否含有全部相等元素</strong>。不过标准库提供了高度优化的<code>bytes.Equal</code>函数来判断两个字节型slice是否相等（限于**[]byte**），但是对于其他类型的slice，我们必须自己展开每个元素进行比较</p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">func equal(x, y []string) bool &#123;    if len(x) !&#x3D; len(y) &#123;        return false    &#125;    for i :&#x3D; range x &#123;        if x[i] !&#x3D; y[i] &#123;            return false        &#125;    &#125;    return true&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果==使用的是<strong>浅度相等</strong>，只要两个slice的指针，长度和容量三个字段相等，那么两个slice就相等。但这样和数组不同的相等测试方法，会让人困惑，如：</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 两个数组相等</span>    a1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    a2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a1 <span class="token operator">==</span> a2<span class="token punctuation">)</span>    <span class="token comment">// true</span>    <span class="token comment">// 如果slice使用的是浅相等</span>    a1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    a2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a1 <span class="token operator">==</span> a2<span class="token punctuation">)</span>   <span class="token comment">// false，和数组的行为不同，造成困惑</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果==使用的是<strong>深度相等</strong>，和数组的行为保持一致，那也会有下面的问题。正常情况下，将一个slice赋值给另一个slice时，我们只是复制slice的结构体，<strong>两个slice的指针都指向同一个底层数组</strong>。</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    s1 <span class="token operator">:=</span> s0    s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>   <span class="token comment">// 通过s1修改，会影响到s0</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>slice唯一合法的比较操作是和nil比较</strong></p><h2 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h2><p>在slice.go下，有一个扩容growslice函数，当切片的容量不足时，便会调用该函数进行切片扩容，关键源码如下所示：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">growslice</span><span class="token punctuation">(</span>et <span class="token operator">*</span>_type<span class="token punctuation">,</span> old slice<span class="token punctuation">,</span> <span class="token builtin">cap</span> <span class="token builtin">int</span><span class="token punctuation">)</span> slice <span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token operator">...</span>    newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>    doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap    <span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">></span> doublecap <span class="token punctuation">&#123;</span>       newcap <span class="token operator">=</span> <span class="token builtin">cap</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span> <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">&#123;</span>          newcap <span class="token operator">=</span> doublecap       <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// Check 0 &lt; newcap to detect overflow</span>          <span class="token comment">// and prevent an infinite loop.</span>          <span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">&#123;</span>             newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span>          <span class="token punctuation">&#125;</span>          <span class="token comment">// Set newcap to the requested cap when</span>          <span class="token comment">// the newcap calculation overflowed.</span>          <span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>             newcap <span class="token operator">=</span> <span class="token builtin">cap</span>          <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，扩容的具体规则为：</p><ol><li>如果期望容量<strong>大于当前容量的两倍</strong>就会使用期望容量；</li><li>如果当前切片的长度<strong>小于 1024</strong> 就会将容量<strong>翻倍</strong>；</li><li>如果当前切片的长度<strong>大于 1024</strong> 就会<strong>每次增加 25% 的容量</strong>，直到新容量大于期望容量；</li></ol><p>上述过程仅是进行了新容量的预估，接下来还需要根据切片中的元素大小<strong>对齐内存</strong>。</p><blockquote><p>比如新容量是3，<code>int</code>类型，则它需要申请<code>24B</code>的内存，此时它会向语言自身的<strong>内存管理模块</strong>去申请内存</p><p>而内存管理模块会提前向操作系统申请一批内存，分为常用的规格管理起来，我们申请内存时，它会帮我们<strong>匹配到足够大，且最接近规格的内存</strong>，可能这里内存管理模块分配给你了<code>32B</code>的内存，所以这个时候新容量变成4个了</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/image-20220105003609592.png" alt="image-20220105003609592"></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//runtime下sizeclasses.go文件，基本的内存单元如下</span><span class="token keyword">var</span> class_to_size <span class="token operator">=</span> <span class="token punctuation">[</span>_NumSizeClasses<span class="token punctuation">]</span><span class="token builtin">uint16</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">,</span> <span class="token number">112</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">144</span><span class="token punctuation">,</span> <span class="token number">160</span><span class="token punctuation">,</span> <span class="token number">176</span><span class="token punctuation">,</span> <span class="token number">192</span><span class="token punctuation">,</span> <span class="token number">208</span><span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">,</span> <span class="token number">240</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">288</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">352</span><span class="token punctuation">,</span> <span class="token number">384</span><span class="token punctuation">,</span> <span class="token number">416</span><span class="token punctuation">,</span> <span class="token number">448</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">,</span> <span class="token number">576</span><span class="token punctuation">,</span> <span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">704</span><span class="token punctuation">,</span> <span class="token number">768</span><span class="token punctuation">,</span> <span class="token number">896</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">1152</span><span class="token punctuation">,</span> <span class="token number">1280</span><span class="token punctuation">,</span> <span class="token number">1408</span><span class="token punctuation">,</span> <span class="token number">1536</span><span class="token punctuation">,</span> <span class="token number">1792</span><span class="token punctuation">,</span> <span class="token number">2048</span><span class="token punctuation">,</span> <span class="token number">2304</span><span class="token punctuation">,</span> <span class="token number">2688</span><span class="token punctuation">,</span> <span class="token number">3072</span><span class="token punctuation">,</span> <span class="token number">3200</span><span class="token punctuation">,</span> <span class="token number">3456</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">4864</span><span class="token punctuation">,</span> <span class="token number">5376</span><span class="token punctuation">,</span> <span class="token number">6144</span><span class="token punctuation">,</span> <span class="token number">6528</span><span class="token punctuation">,</span> <span class="token number">6784</span><span class="token punctuation">,</span> <span class="token number">6912</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">,</span> <span class="token number">9472</span><span class="token punctuation">,</span> <span class="token number">9728</span><span class="token punctuation">,</span> <span class="token number">10240</span><span class="token punctuation">,</span> <span class="token number">10880</span><span class="token punctuation">,</span> <span class="token number">12288</span><span class="token punctuation">,</span> <span class="token number">13568</span><span class="token punctuation">,</span> <span class="token number">14336</span><span class="token punctuation">,</span> <span class="token number">16384</span><span class="token punctuation">,</span> <span class="token number">18432</span><span class="token punctuation">,</span> <span class="token number">19072</span><span class="token punctuation">,</span> <span class="token number">20480</span><span class="token punctuation">,</span> <span class="token number">21760</span><span class="token punctuation">,</span> <span class="token number">24576</span><span class="token punctuation">,</span> <span class="token number">27264</span><span class="token punctuation">,</span> <span class="token number">28672</span><span class="token punctuation">,</span> <span class="token number">32768</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li>《Go语言设计与实现》</li><li>《Go语言圣经》</li><li> 幼麟实验室的Golang合辑</li><li>Go语言中文文档</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层分析 </tag>
            
            <tag> slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数调用栈的传参与返回值</title>
      <link href="/blog-article/2021/10/30/han-shu-diao-yong-zhan-de-chuan-can-yu-fan-hui-zhi/"/>
      <url>/blog-article/2021/10/30/han-shu-diao-yong-zhan-de-chuan-can-yu-fan-hui-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>我们知道，由于Go语言是值传递，如果在被调用函数内部交换两个数的值，调用者内部对应的实参是不会发生变化的，就如下所示：</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/swap%E5%87%BD%E6%95%B0.PNG"></p><p>但这个现象的原因从函数调用栈来说具体的机理是什么呢？我们通过函数调用栈看看问题到底出在哪</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/swap%E6%A0%88%E5%B8%A7.PNG"></p><p>由于函数调用没有返回值，所以局部变量后面就是给被调用函数传入的参数$args$，注意调用函数的<strong>参数入栈顺序由右到左，返回值也是一样</strong>（原因是这样被调用函数通过**$sp$+偏移寻址**就比较方便了）</p><p>可以看出，当<code>swap</code>函数交换两数时，交换的是<code>args</code>内的$a、b$，而不是<code>main</code>函数中的局部变量，所以<code>main</code>函数中的$a、b$交换失败。</p><h2 id="传指针的例子"><a href="#传指针的例子" class="headerlink" title="传指针的例子"></a>传指针的例子</h2><p>同理与上面的例子，我们便可以很容易理解传指针时为什么可以成功交换$a、b$的值</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/swap%E5%87%BD%E6%95%B02.PNG"></p><p>此时的栈帧空间分布如下：</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/swap%E6%A0%88%E5%B8%A72.PNG"></p><p><code>swap</code>执行到<code>*a,*b=*b,*a</code>时，交换的是这两个指针指向的数据，也就是这两个地址的数据，所以这一次能交换成功</p><h2 id="匿名函数返回值"><a href="#匿名函数返回值" class="headerlink" title="匿名函数返回值"></a>匿名函数返回值</h2><p>Go语言支持多返回值，所以在<strong>栈上分配返回值空间</strong>更合适</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%8C%BF%E5%90%8D%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0.PNG"></p><p>首先，栈帧上所有的$a、b$初始均等于0，执行到①处时，被调用函数的参数<code>args</code>上的$a$自增为1，接着执行到②，<code>incr</code>函数栈帧的$b$被赋值等于1。</p><blockquote><p>注：<strong>defer与return时机</strong></p><p>return赋值和返回是两个步骤，不是原子操作，如果有defer会插在两个步骤中:</p><ol><li>返回值赋值(return value)</li><li>defer语句 </li><li>返回值真正返回，调用函数结束</li></ol></blockquote><p>所以<code>return</code>函数先将<code>incr</code>函数栈帧的$b$赋值给返回值，也就是此时的栈空间是这样的</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%8C%BF%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7.PNG"></p><p>接着执行<code>defer</code>函数，<code>args</code>上的$a$再自增1，<code>incr</code>函数局部变量$b$也自增1，然后<code>incr</code>结束。此时返回值为1，所以<code>main</code>函数中的$b$最终被赋值为1，而<code>main</code>函数中的$a$并不会收到<code>incr</code>函数的影响，值仍然为0。最终的栈内布局是这样的：</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%8C%BF%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A72.PNG"></p><p><strong>所以最终输出的是0和1</strong></p><h2 id="具名返回值函数"><a href="#具名返回值函数" class="headerlink" title="具名返回值函数"></a>具名返回值函数</h2><p>假如我们其他都不变，只把这里的局部变量b，改成命名返回值，看看有什么不同</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/6a677dc56a02460b895f40b4063dcdbe.png"></p><p>当执行到<code>a++</code>时，参数$a$自增1，由于是具名返回值函数，此时返回值$b$被赋予为1</p><p>接着<code>defer</code>函数，参数$a$再自增1，返回值b也自增1，<code>incr</code>结束，所以最终返回值$b$的值为2</p><h2 id="调用多个函数时的小问题"><a href="#调用多个函数时的小问题" class="headerlink" title="调用多个函数时的小问题"></a>调用多个函数时的小问题</h2><p>如果一个函数A调用了两个函数B和C。但是这<strong>两个函数的参数和返回值占用的空间并不相同</strong>，而Go语言的函数栈帧是一次性分配的，所以要以<strong>最大的参数加返回值空间为标准来分配栈帧空间</strong>，才能满足所有被调函数的需求</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0.PNG"></p><p>假设B的参数和返回值占用的空间大，当调用B时，B的参数和返回值可以把分配的参数加返回值空间占满没有问题，但是调用B时，B的参数和返回值<strong>只会占用靠近栈顶的那部分空间</strong>（即上图方框中靠下的部分）</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B02.PNG"></p><blockquote><p>原因是虽然上面空出来一块，但是被调用者<strong>通过栈指针相对寻址</strong>自己的参数和返回值时会比较方便</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>幼麟实验室的Golang合辑</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层分析 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数调用栈分析</title>
      <link href="/blog-article/2021/10/30/han-shu-diao-yong-zhan-fen-xi/"/>
      <url>/blog-article/2021/10/30/han-shu-diao-yong-zhan-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="函数基本结构"><a href="#函数基本结构" class="headerlink" title="函数基本结构"></a>函数基本结构</h2><p>G语言中函数的声明的基本形式如下：</p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">func name(parameter-list) (result-list) &#123;    body&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中<strong>函数的类型被称为函数的签名</strong>。如果两个函数<strong>形式参数列表</strong>和<strong>返回值列表</strong>中的<strong>变量类型</strong>一一对应，那么这两个函数被认为有相同的类型或签名。</p><p>形参和返回值的<strong>变量名</strong>不影响函数签名，也不影响它们是否可以以省略参数类型的形式表示。</p><p>Go语言的实参通过<strong>值的方式传递</strong>，因此函数的形参是实参的拷贝，只有传递指针、slice(切片)、map、function、channel等类型才可能导致实参的修改。</p><h2 id="函数栈帧布局"><a href="#函数栈帧布局" class="headerlink" title="函数栈帧布局"></a>函数栈帧布局</h2><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A7.png" alt="函数栈帧"></p><p>我们用Go语言写的函数，会被编译器编译为一堆机器指令，写入可执行文件，程序执行时，可执行文件被加载到内存，这些机器指令对应到虚拟地址空间中，位于代码段</p><p>如果在一个函数中调用另一个函数，编译器就会对应生成一条<code>call</code>指令，程序执行到这条指令时，就会跳转到被调用函数处开始执行，而每个函数的最后都有一条<code>ret</code>指令，负责在函数结束后跳回到调用处，继续执行。</p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A72.png" /><p>由图中可以看出，一个栈帧的从栈底到栈顶的布局是：</p><blockquote><p> <strong>调用者栈基  =&gt; 局部变量 =&gt; 被调用函数返回值 =&gt; 被调用函数参数</strong></p></blockquote><p>而之前说的<code>call</code>指令，就只做两件事：</p><blockquote><ol><li>将下一条指定的地址入栈，这就是<strong>返回地址</strong>，被调用函数执行结束后会跳回到这里。</li><li>跳转到<strong>被调用函数的入口处</strong>开始执行</li></ol></blockquote><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E6%A0%88%E5%B8%A73.png"></p><p>所有的函数的栈帧布局都遵循统一的约定，故被调用者是通<strong>过栈指针加上相应的偏移</strong>来定位到每个参数和返回值的</p><blockquote><p>注意，返回地址是被CALL指令压栈的，故其<strong>既不属于调用者栈帧，也不属于被调用者栈帧的内容</strong>。</p></blockquote><h2 id="栈帧的内存分配"><a href="#栈帧的内存分配" class="headerlink" title="栈帧的内存分配"></a>栈帧的内存分配</h2><p>Go语言的栈不是逐步扩张的，而是<strong>一次性分配</strong>，也就是在<strong>分配栈帧时，直接将栈指针移动到所需最大栈空间的位置</strong>，然后通过<strong>栈指针+偏移值这种相对寻址方式</strong>使用函数栈帧。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.PNG"></p><p>之所以这样分配，就是为了防止出现上图中所示的访问越界的情况。</p><p>函数栈帧的大小，可以在编译时期确定，对于栈消耗较大的函数，Go语言的编译器会在<strong>函数头部插入检测代码</strong>，如果发现需要进行“栈增长”，就会另外分配一段足够大的栈空间，并把原来栈上的数据拷贝过来，并且将原来这段栈空间释放。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%802.PNG"></p><h2 id="函数跳转与返回的实现"><a href="#函数跳转与返回的实现" class="headerlink" title="函数跳转与返回的实现"></a>函数跳转与返回的实现</h2><p>假设一个函数$A$在$a1$处调用函数$B$，起初栈内存布局以及寄存器情况如下：</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E8%B7%B3%E8%BD%AC%E4%B8%8E%E8%BF%94%E5%9B%9E.PNG"></p><p>代码执行到$a1$，调用<code>call</code>指令，便会执行两步：</p><ol><li><strong>把下一条指令执行地址$a2$入栈保存起来，即保存到$s3$处</strong></li><li><strong>跳转到指令执行地址$b1$处</strong></li></ol><p>接着函数$B$代码开始执行，先把 $sp$ 向下移动24字节（这里是说明性演示，假设分配的栈帧大小即为24字节），为自己分配足够大的栈帧；接着执行$b2$这条指令，把<strong>调用者栈基</strong><code>(caller’s bp -&gt; s1)</code>存到$sp+16$的地方，接下来$b3$指令把$sp+16$的地址存入栈基寄存器$bp$，接下来就可以执行函数$B$剩下的指令了。</p><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E8%B7%B3%E8%BD%AC%E4%B8%8E%E8%BF%94%E5%9B%9E2.PNG"></p><p>执行完$B$剩余的指令后，在<code>ret</code>指令之前，编译器还会插入两条指令：</p><blockquote><ol><li>恢复调用者$A$的栈基地址，它之前被存储在$sp+16$字节这里，这就是为什么栈帧布局第一条就是<code>caller’s bp</code>的原因，</li><li>释放自己的栈帧空间，分配时向下移动多少，释放时就向上移动多少</li></ol></blockquote><p><img src="https://gitee.com/DestiNationGitee/drawing-bed/raw/master/blogImg/%E5%87%BD%E6%95%B0%E8%B7%B3%E8%BD%AC%E4%B8%8E%E8%BF%94%E5%9B%9E3.PNG"></p><p>接着就是<code>ret</code>指令了，其首先是弹出<code>call</code>指令压栈的<strong>返回地址</strong>，这里即为$sp$指向的$a2$；第二，指令指针寄存器跳转到这个返回地址，然后代码就可以重新从$a2$执行了</p><blockquote><p>总的来说，函数通过<code>call</code>指令实现跳转，而每个函数开始时会分配栈帧，结束前又会释放自己的栈帧，<code>ret</code>指令又会把<code>call</code>恢复到<code>call</code>之前的样子，通过这些指令的配合能够实现函数的层层嵌套。</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol><li>幼麟实验室的Golang合辑</li><li>《Go语言圣经》</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang底层分析 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog-article/2021/10/27/hello-world/"/>
      <url>/blog-article/2021/10/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
